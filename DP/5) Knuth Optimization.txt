//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*                                      Knuth (Yao-style) optimization                                      */
//
// DP Range optimization from O(N^3) to O(N^2), or may be from O(N^4) to O(N^3).
//
// DP form  dp[l, r] = min(C(l, r) + dp[l, j] + dp[j + 1, r]), where l <= j < r.
//
// Condition  opt[l, r - 1] <= opt[l, r] <= opt[l + 1, r], or
// given a <= b <= c <= d, C(a, c) + C(b, d) <= C(a, d) + C(b, c) [QI] & C(b, c) <= C(a, d) [monotonicity].
//
// knuth optimization is applicable if adding elements to the right of the array,
// will cause the pivot to move to right (old pivot <= new pivot), or vice versa.
//
// keywords: 1) divide the array without determining the lenght/number of subarrays (when number of subarrays is specified  D&C).
//           2) slimes problem idea (which pivot is the best to choose first),
//           3)
//
// problems: 1) https://codeforces.com/contest/1101/submission/319774966
//           2)
//
//


//-------------------------



// Optimal Binary Search Tree + Build the Binary Tree (https://vjudge.net/problem/UVA-10304)

void solve()
{

    ll n; cin >> n;
    vector < ll > a(n + 1), pre(n + 1, 0);
    for(ll i = 1; i <= n; i++) cin >> a[i], pre[i] = pre[i - 1] + a[i];

    vector < vector < ll > > dp(n + 2, vector < ll > (n + 2)), opt(n + 2, vector < ll > (n + 2));
    for(ll len = 0; len <= n; len++)
    {
        for(ll l = 1; l <= n; l++)
        {
            ll r = l + len - 1;
            if(r > n) break;

            ll &ret = dp[l][r];

            if(l >= r)
            {
                ret = 0;
                opt[l][r] = l;
                continue;
            }
            ret = oo;

            for(ll i = opt[l][r - 1]; i <= opt[l + 1][r]; i++)
            {
                ll cost = (pre[r] - pre[l - 1] - a[i]) + dp[l][i - 1] + dp[i + 1][r];
                if(cost < ret) // i think <= may be faster
                {
                    ret = cost;
                    opt[l][r] = i;
                }
            }

        }
    }
    cout << dp[1][n] << endl;



    // Build function
    vector < string > ans(n + 1, "");
    function < void(ll, ll, string) > build = [&](ll l, ll r, string s)
    {
        if(l > r) return;
        if(l == r)
        {
            ans[l] = s;
            return;
        }
        ans[opt[l][r]] = s;
        build(l, opt[l][r] - 1, s + "0");
        build(opt[l][r] + 1, r, s + "1");
    };
    build(1, n, "");
    ans[opt[1][n]] = "root";
    for(ll i = 1; i <= n; i++) cout << ans[i] << ' ';
    cout << endl;



    return;
}


//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
