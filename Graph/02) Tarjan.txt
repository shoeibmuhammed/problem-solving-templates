

/*                           (1) Tarjan for Directed graph: get SSC, Bridges, Condensation Graph in O(v + E)                           */
//
// n (nubmer of nodes), m (number of edges), timer, rem_nodes
// graph (directed graph), scc (every scc nodes in a vector), condensation_graph (acyclic graph after graph's compression)
// dfsn (dfs order number), lowlink (nearst ansector i cen get), instack (check if i reach a node in the stack)
// id (0-indexed) --> very usefull, every node in the same have the same id --> check if two nodes in the same scc or not in O(1) --> id[u] == id[v] ? same SCC : diff SCC
// id_to_head -->  (id of SCC --> head of SCC),  my_head --> (node --> head of it's SCC)
// bridges
// st
//


ll n, m, timer, rem_nodes;
vector < vector < ll > > graph, scc, condensation_graph;
vector < ll > dfsn, lowlink, instack, id, id_to_head, my_head;
vector < pair < ll, ll > > bridges;
stack < ll > st;


void init()
{
    timer = 1;
    rem_nodes = n;

    graph.assign(n + 1, vector < ll > ());
    scc.clear();
    condensation_graph.assign(n + 1, vector < ll > ());

    dfsn.assign(n + 1, -1);
    lowlink.assign(n + 1, -1);
    instack.assign(n + 1, 0);
    id.assign(n + 1, -1);
    id_to_head.assign(n + 1, -1);
    my_head.assign(n + 1, -1);

    bridges.clear();

    while(!st.empty()) st.pop();
}



void tarjan(ll root)
{
    dfsn[root] = lowlink[root] = timer++;
    instack[root] = 1;
    st.push(root);

    for(const auto &i : graph[root])
    {

        if(dfsn[i] == -1) // mnot visited yet!
        {
            tarjan(i);
            lowlink[root] = min(lowlink[root], lowlink[i]);     // minimize with the min lowlink my child can get to it

            if(dfsn[i] == lowlink[i]) // my child can't get to a lowlink smaller than me --> i form a bridge with my child!
                bridges.push_back({root, i});
        }
        else if(instack[i]) // visited & in the current stack (return to an ancestor of me!) --> cyclic --> minimize with it
        {
            lowlink[root] = min(lowlink[root], dfsn[i]);            // get the first (nearst) ansector not lowest number --> always same result --> Works for SSC, Bridges, Articulation points
            // lowlink[root] = min(lowlink[root], lowlink[i]);      // get the lowest ansector --> different results according to DFS traversal order
        }
        else // visitied & not in the current stack  --> my child has been assigned to another SCC different than me --> bridge
        {
            bridges.push_back({root, i});
        }

    }

    // (dfsn == low link)  -->  Head of a SCC
    if(dfsn[root] == lowlink[root])
    {
        scc.push_back(vector < ll > ()); // add new ssc
        ll x = -1;
        while(x != root)
        {
            x = st.top(); st.pop(); instack[x] = 0;
            rem_nodes--;
            scc.back().push_back(x);               // add a node to the last SCC
            id[x] = (ll)scc.size() - 1;            // give same id's to each node in the same SCC
            id_to_head[(ll)scc.size() - 1] = x;    // id of each SCC --> head of the SCC
            my_head[x] = root;
        }
    }

}


// Condensation Graph (no. of nodes == no. of SCC)  -->  Compress each SCC nodes to only one node (head of the SCC)
void scc_to_condensation_graph()
{
    for(ll i = 1; i <= n; i++)
    {
        for(const auto &j : graph[i])
        {
            if(my_head[i] != my_head[j]) // edges between two different SCC --> forms new edge in Condensation Graph
            {
                condensation_graph[my_head[i]].push_back(my_head[j]);
            }
        }
    }
}


void solve()
{

    cin >> n >> m;
    init();

    for(ll i = 1; i <= m; i++)
    {
        ll u, v; cin >> u >> v;
        graph[u].push_back(v);
    }

    for(ll i = 1; i <= n; i++)
        if(dfsn[i] == -1) tarjan(i);

    scc_to_condensation_graph();



    // .............................................

    cout << "SSC components are " << (ll)scc.size() << ": " << endl;
    for(const auto &i : scc)
    {
        for(const auto &j : i)
            cout << j << ' ';
        cout << " -- ";
    }
    cout << endl;

    cout << "Bridges are " << (ll)bridges.size() << ": " << endl;
    for(const auto &i : bridges) cout << i.first << ' ' << i.second << " -- ";
    cout << endl;

    cout << "Condensation graph:" << endl;
    for(ll i = 1; i <= n; i++)
    {
        for(const auto &j : condensation_graph[i])
            cout << i << ' ' << j << " -- ";
    }
    cout << endl;

    // .............................................









    return;
}





//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




/*                           (2) Tarjan for Undirected graph: get CC, Bridges, Condensation Graph in O(v + E)                           */


// n (nubmer of nodes), m (number of edges), timer, rem_nodes
// graph (undirected graph), cc (every cc nodes in a vector), condensation_graph (acyclic graph after graph's compression)
// dfsn (dfs order number), lowlink (nearst ansector i cen get), instack (check if i reach a node in the stack) --> useless here (visited nodes always in stack!)
// id (0-indexed) --> very usefull, every node in the same have the same id --> check if two nodes in the same cc or not in O(1) --> id[u] == id[v] ? same CC : diff CC
// id_to_head -->  (id of CC --> head of CC),  my_head --> (node --> head of it's CC)
// bridges
// st



ll n, m, timer, rem_nodes;
vector < vector < ll > > graph, cc, condensation_graph;
vector < ll > dfsn, lowlink, instack, id, id_to_head, my_head;
vector < pair < ll, ll > > bridges;
stack < ll > st;


void init()
{
    timer = 1;
    rem_nodes = n;

    graph.assign(n + 1, vector < ll > ());
    cc.clear();
    condensation_graph.assign(n + 1, vector < ll > ());

    dfsn.assign(n + 1, -1);
    lowlink.assign(n + 1, -1);
    instack.assign(n + 1, 0); // useless!
    id.assign(n + 1, -1);
    id_to_head.assign(n + 1, -1);
    my_head.assign(n + 1, -1);

    bridges.clear();

    while(!st.empty()) st.pop();
}


void tarjan(ll root, ll parent = -1)
{
    dfsn[root] = lowlink[root] = timer++;
    st.push(root);

    for(const auto &i : graph[root])
    {
        if(dfsn[i] == -1) // not visited node --> minimize with lowlink of it
        {
            tarjan(i, root);
            lowlink[root] = min(lowlink[root], lowlink[i]);

            // if(lowlink[i] > dfsn[root])  // my child can't get a lowlink smaller than or equal to my dfsn ->  a bridge between me and my child
            if(lowlink[i] == dfsn[i])  // my child can't get a lowlink smaller than his dfsn -->  a bridge between me and my child
                bridges.push_back({root, i});
        }
        else if(i != parent) // visited --> (return to an ancestor of me!) --> minimize with it
        {
            lowlink[root] = min(lowlink[root], dfsn[i]);         // minimize with the first (nearst) ansector to me
        }
    }


    // (dfsn == low link)  -->  Head of a CC
    if(lowlink[root] == dfsn[root])
    {
        cc.push_back(vector < ll > ()); // add new cc
        ll x = -1;
        while(x != root)
        {
            x = st.top(); st.pop(); instack[x] = 0;
            rem_nodes--;
            cc.back().push_back(x);               // add a node to the last CC
            id[x] = (ll)cc.size() - 1;            // give same id's to each node in the same CC
            id_to_head[(ll)cc.size() - 1] = x;    // id of each SCC --> head of the CC
            my_head[x] = root;
        }
    }
}


// Condensation Graph (no. of nodes == no. of CC)  -->  Compress each CC nodes to only one node (head of the CC)
void cc_to_condensation_graph()
{
    for(ll i = 1; i <= n; i++)
    {
        for(const auto &j : graph[i])
        {
            if(my_head[i] != my_head[j]) // edges between two different CC --> forms new edge in Condensation Graph
            {
                condensation_graph[my_head[i]].push_back(my_head[j]);
            }
        }
    }
}

void solve()
{

    cin >> n >> m;
    init();
    for(ll i = 1; i <= m; i++)
    {
        ll u, v; cin >> u >> v;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }

    for(ll i = 1; i <= n; i++)
        if(dfsn[i] == -1) tarjan(i);
    cc_to_condensation_graph();



    // .............................................

    cout << "CC components are " << (ll)cc.size() << ": " << endl;
    for(const auto &i : cc)
    {
        for(const auto &j : i)
            cout << j << ' ';
        cout << " -- ";
    }
    cout << endl;

    cout << "Bridges are " << (ll)bridges.size() << ": " << endl;
    for(const auto &i : bridges) cout << i.first << ' ' << i.second << " -- ";
    cout << endl;

    cout << "Condensation graph:" << endl;
    for(ll i = 1; i <= n; i++)
    {
        for(const auto &j : condensation_graph[i])
            cout << i << ' ' << j << " -- ";
    }
    cout << endl;

    // .............................................










    return;
}





//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




/*                           (3) Tarjan for Undirected graph: get Articulation Points in O(v + E)                           */

// Articulation points --> points when we remove it --> graph become disconnected --> number of components++
// Biconnected Graph --> graph with zero articulation points --> one BCC
// n articulaion points --> n/n+1 BCC


// n (nubmer of nodes), m (number of edges), timer, root_flag
// graph (undirected graph)
// dfsn (dfs order number), lowlink (nearst ansector i cen get), is_art
// art_points


ll n, m, timer;
bool root_flag;
vector < vector < ll > > graph;
vector < ll > dfsn, lowlink, is_art;
set < ll > art_points;

void init()
{
    timer = 1;
    root_flag = 0;

    graph.assign(n + 1, vector < ll > ());

    dfsn.assign(n + 1, -1);
    lowlink.assign(n + 1, -1);
    is_art.assign(n + 1, 0);

    art_points.clear();
}


void tarjan(ll root, ll parent = -1)
{
    dfsn[root] = lowlink[root] = timer++;

    for(const auto &i : graph[root])
    {

        if(dfsn[i] == -1) // not visited node --> minimize with lowlink of it
        {
            tarjan(i, root);
            lowlink[root] = min(lowlink[root], lowlink[i]);

            if(lowlink[i] >= dfsn[root]) // my child can't get to nodes lower than my dfsn
            {
                if(dfsn[root] == 1 && !root_flag) // first BCC with the root --> ignore it
                {
                    root_flag = 1;
                }
                else
                {
                    is_art[root] = 1;
                    art_points.insert(root);
                }

            }

        }
        else if(i != parent) // visited --> (return to an ancestor of me!) --> minimize with it
        {
            lowlink[root] = min(lowlink[root], dfsn[i]);
        }

    }

}




void solve()
{

    cin >> n >> m;
    init();
    for(ll i = 1; i <= m; i++)
    {
        ll u, v; cin >> u >> v;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }


    for(ll i = 1; i <= n; i++)
        if(dfsn[i] == -1) tarjan(i);


    // .............................................

    cout << "articulation points are " << (ll)art_points.size() << ": " << endl;
    for(const auto &i : art_points) cout << i << " - ";
    cout << endl;

    // .............................................











    return;
}



//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*                           (4) Tarjan for Undirected graph: get Articulaton points, Biconnected Components (BCC)   in O(v + E)                 */

// BCC: is a maximal subgraph of a given graph such that the subgraph is biconnected
// Biconnected Graph (zero articulation points) has only one BCC (the graph it self)
// two nodes connected with one edge is BCC


// n (nubmer of nodes), m (number of edges), timer, root_flag
// graph (undirected graph), bcc
// dfsn (dfs order number), lowlink (nearst ansector i cen get), is_art
// art_points, st, done


ll n, m, timer;
bool root_flag;
vector < vector < ll > > graph;
vector < vector < pair < ll, ll > > > bcc;
vector < ll > dfsn, lowlink, is_art;
set < ll > art_points;
stack < pair < ll, ll > > st;
map < pair < ll, ll >, ll > done;

void init()
{
    timer = 1;
    root_flag = 0;

    graph.assign(n + 1, vector < ll > ());
    bcc.clear();

    dfsn.assign(n + 1, -1);
    lowlink.assign(n + 1, -1);
    is_art.assign(n + 1, 0);

    art_points.clear();

    while(!st.empty()) st.pop();

    done.clear();
}



void tarjan(ll root, ll parent = -1)
{
    dfsn[root] = lowlink[root] = timer++;

    for(const auto &i : graph[root])
    {
        if(root != i && dfsn[i] < dfsn[root])
            st.push({root, i});

        if(dfsn[i] == -1) // not visited node --> minimize with lowlink of it
        {
            tarjan(i, root);
            lowlink[root] = min(lowlink[root], lowlink[i]);

            if(lowlink[i] >= dfsn[root]) // my child can't get to nodes lower than my dfsn
            {
                if(dfsn[root] == 1 && !root_flag) // first BCC with the root --> ignore it
                {
                    root_flag = 1;
                }
                else
                {
                    is_art[root] = 1;
                    art_points.insert(root);
                }


                pair < ll, ll > edge;
                bcc.push_back(vector < pair < ll, ll > > ());
                do
                {
                    edge = st.top(); st.pop();

                    if(!done[{edge.first, edge.second}])
                        bcc.back().push_back({edge.first, edge.second});

                    done[{edge.first, edge.second}] = done[{edge.second, edge.first}] =1;
                } while(edge.first != root || edge.second != i);


            }

        }
        else if(i != parent) // visited --> (return to an ancestor of me!) --> minimize with it
        {
            lowlink[root] = min(lowlink[root], dfsn[i]);
        }

    }

}




void solve()
{

    cin >> n >> m;
    init();
    for(ll i = 1; i <= m; i++)
    {
        ll u, v; cin >> u >> v;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }


    for(ll i = 1; i <= n; i++)
        if(dfsn[i] == -1) tarjan(i);


    // .............................................

    cout << "articulation points are " << (ll)art_points.size() << ": " << endl;
    for(const auto &i : art_points) cout << i << " - ";
    cout << endl;


    cout << "BCC: " << endl;
    for(const auto &i : bcc)
    {
        for(const auto &j : i)
            cout << j.first << ' ' << j.second << " -- ";
        cout << endl;
    }

    // .............................................











    return;
}

