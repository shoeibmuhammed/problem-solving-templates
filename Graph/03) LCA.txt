//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                         LCA (Lowest Common Ancestor)                    */
// for two nodes u and v in a tree, the lca(u, v) is the lowest (deepest) node that is an ancestor of both.
// Preprocessing in O(n * log(n)), Query in O(log(n))
//


// LCA variables
const ll N = (ll)5e5 + 5, LOG = 20;
vector < ll > graph[N];
ll depth[N], parent[N][LOG + 1];


// build
void init(ll root = 1, ll par = 0)
{
    parent[root][0] = par;
    for(ll i = 1; i <= LOG; i++)
        parent[root][i] = parent[parent[root][i - 1]][i - 1];

    for(const auto &i : graph[root])
    {
        if(i == par) continue;
        depth[i] = depth[root] + 1;
        init(i, root);
    }

    return;
}

// get the Kth ancestor
ll getKthAncestor(ll root, ll k)
{
    if(k > depth[root]) return -1;

    for(ll i = LOG; i >= 0; i--)
        if(k & (1ll << i))
            root = parent[root][i];

    return root;
}

// get the lowest common ancestor of two nodes
ll lca(ll u, ll v)
{
    if(depth[u] > depth[v]) swap(u, v);

    v = getKthAncestor(v, depth[v] - depth[u]);

    if(u == v) return u;

    for(ll i = LOG; i >= 0; i--)
        if(parent[u][i] != parent[v][i])
            u = parent[u][i], v = parent[v][i];

    return parent[u][0];
}

// get the distance of the path between two nodes
ll getDist(ll u, ll v)
{
    ll l = lca(u, v);
    return depth[u] + depth[v] - 2*depth[l];
}

// check if v is an ancestor of u
bool isAncestor(ll u, ll v)
{
    return lca(u, v) == v;
}

// get the Kth node in the path from u to v (u is 0th node)
ll getKthNode(ll u, ll v, ll k)
{
    ll l = lca(u, v);
    ll d = depth[u] + depth[v] - 2*depth[l];

    if(k > d) return -1;

    if(depth[l] + k <= depth[u]) return getKthAncestor(u, k);

    k -= (depth[u] - depth[l]);

    return getKthAncestor(v, depth[v] - depth[l] - k);
}



//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                         LCA (Lowest Common Ancestor)                    */
// for two nodes u and v in a tree, the lca(u, v) is the lowest (deepest) node that is an ancestor of both.
// Preprocessing in O(n * log(n)), Query in O(log(n))
//

// LCA variables
const ll N = (ll)5e5 + 5, LOG = 20;
vector < pair < ll, ll > > graph[N];
ll depth[N], parent[N][LOG + 1], MX[N][LOG + 1], MN[N][LOG + 1];

// build
void init(ll root = 1, ll par = 0, ll val = 0)
{
    parent[root][0] = par;
    MN[root][0] = val;
    MX[root][0] = val;
    for(ll i = 1; i <= LOG; i++)
    {
        parent[root][i] = parent[parent[root][i - 1]][i - 1];
        MN[root][i] = min(MN[root][i - 1], MN[parent[root][i - 1]][i - 1]);
        MX[root][i] = max(MX[root][i - 1], MX[parent[root][i - 1]][i - 1]);
    }

    for(const auto &i : graph[root])
    {
        if(i.first == par) continue;
        depth[i.first] = depth[root] + 1;
        init(i.first, root, i.second);
    }

    return;
}

// get the Kth ancestor
ll getKthAncestor(ll root, ll k)
{
    if(k > depth[root]) return -1;

    for(ll i = LOG; i >= 0; i--)
        if(k & (1ll << i))
            root = parent[root][i];

    return root;
}

// get the lowest common ancestor of two nodes
ll lca(ll u, ll v)
{
    if(depth[u] > depth[v]) swap(u, v);

    v = getKthAncestor(v, depth[v] - depth[u]);

    if(u == v) return u;

    for(ll i = LOG; i >= 0; i--)
        if(parent[u][i] != parent[v][i])
            u = parent[u][i], v = parent[v][i];

    return parent[u][0];
}

// get the distance of the path between two nodes
ll getDist(ll u, ll v)
{
    ll l = lca(u, v);
    return depth[u] + depth[v] - 2*depth[l];
}

// check if v is an ancestor of u
bool isAncestor(ll u, ll v)
{
    return lca(u, v) == v;
}

// get the Kth node in the path from u to v (u is 0th node)
ll getKthNode(ll u, ll v, ll k)
{
    ll l = lca(u, v);
    ll d = depth[u] + depth[v] - 2*depth[l];

    if(k > d) return -1;

    if(depth[l] + k <= depth[u]) return getKthAncestor(u, k);

    k -= (depth[u] - depth[l]);

    return getKthAncestor(v, depth[v] - depth[l] - k);
}

// return the mx edge weight on the path from u to v
ll _getMx(ll root, ll k)
{
    // if(k > depth[root]) return -1;

    ll res = -oo;
    for(ll i = LOG; i >= 0; i--)
    {
        if(k & (1ll << i))
        {
            res = max(res, MX[root][i]);
            root = parent[root][i];
        }
    }

    return res;
}
ll getMX(ll u, ll v)
{
    ll l = lca(u, v);
    return max(_getMx(u, depth[u] - depth[l]), _getMx(v, depth[v] - depth[l]));
}

// return the mn edge weight on the path from u to v
ll _getMN(ll root, ll k)
{
    // if(k > depth[root]) return -1;

    ll res = oo;
    for(ll i = LOG; i >= 0; i--)
    {
        if(k & (1ll << i))
        {
            res = min(res, MN[root][i]);
            root = parent[root][i];
        }
    }

    return res;
}
ll getMN(ll u, ll v)
{
    ll l = lca(u, v);
    return min(_getMN(u, depth[u] - depth[l]), _getMN(v, depth[v] - depth[l]));
}


void solve()
{


    ll n; cin >> n;
    for(ll i = 1; i <= n - 1; i++)
    {
        ll u, v, t; cin >> u >> v >> t;
        graph[u].push_back({v, t});
        graph[v].push_back({u, t});
    }

    init();

    ll q; cin >> q;
    while(q--)
    {
        ll u, v; cin >> u >> v;
        cout << getMN(u, v) << ' ' << getMX(u, v) << endl;
    }

    for(ll i = 1; i <= n; i++) graph[i].clear();



    return;
}




//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


