//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                                      Hungarian                                        */
// Finds the minimum cost with maximum matching in O(n^3) (1-indexed)
// works with negative weighted edges
// better than mcmf in assignment problems!
// for finding maximum cost with maximum matching ïƒ  -cost, -matching()


struct Hungarian
{
    int start, finish, n, isMax;
    vector < ll > fx, fy, d;
    queue < int > q;
    vector < int > l, r, arg, trace;
    vector < vector < ll > > c;

    Hungarian() { }

    Hungarian(int n1, int n2, int flag = 0): n(max(n1, n2))
    {
        isMax = flag;
        c.assign(n + 1, vector < ll > (n + 1, (isMax ? 0 : OO)));
        fx.assign(n + 1, 0);
        fy.assign(n + 1, 0);
        d.assign(n + 1, 0);
        l.assign(n + 1, 0);
        r.assign(n + 1, 0);
        arg.assign(n + 1, 0);
        trace.assign(n + 1, 0);
    }

    void add_edge(int u, int v, ll cost) { c[u][v] = min(c[u][v], (isMax? -cost : cost)); }

    inline ll getC(int u, int v) { return c[u][v] - fx[u] - fy[v]; }

    void initBFS()
    {
        while(!q.empty()) q.pop();
        q.push(start);
        for(int i = 0; i <= n; i++) trace[i] = 0;
        for(int v = 1; v <= n; v++)
        {
            d[v] = getC(start, v);
            arg[v] = start;
        }
        finish = 0;
    }

    void findAugPath()
    {
        while(!q.empty())
        {
            int u = q.front(); q.pop();
            for(int v = 1; v <= n; v++)
            {
                if(trace[v]) continue;

                ll w = getC(u, v);
                if(!w)
                {
                    trace[v] = u;
                    if(!r[v])
                    {
                        finish = v;
                        return;
                    }
                    q.push(r[v]);
                }
                if(d[v] > w)
                {
                    d[v] = w;
                    arg[v] = u;
                }
            }
        }
    }

    void subX_addY()
    {
        ll delta = OO;
        for(int v = 1; v <= n; v++) if(!trace[v] && d[v] < delta) delta = d[v];

        fx[start] += delta;
        for (int v = 1; v <= n; ++v)
        {
            if(trace[v])
            {
                int u = r[v];
                fy[v] -= delta;
                fx[u] += delta;
            }
            else
            {
                d[v] -= delta;
            }
        }

        for(int v = 1; v <= n; v++)
        {
            if(!trace[v] && !d[v])
            {
                trace[v] = arg[v];
                if(!r[v])
                {
                    finish = v;
                    return;
                }
                q.push(r[v]);
            }
        }
    }

    void Enlarge()
    {
        do
        {
            int u = trace[finish];
            int nxt = l[u];
            l[u] = finish;
            r[finish] = u;
            finish = nxt;
        } while (finish);
    }


    ll maximum_matching_cost()
    {
        for(int u = 1; u <= n; u++)
        {
            fx[u] = c[u][1];
            for(int v = 1; v <= n; v++) fx[u] = min(fx[u], c[u][v]);
        }

        for(int v = 1; v <= n; v++)
        {
            fy[v] = c[1][v] - fx[1];
            for(int u = 1; u <= n; u++) fy[v] = min(fy[v], c[u][v] - fx[u]);
        }

        for(int u = 1; u <= n; u++)
        {
            start = u;
            initBFS();
            while(!finish)
            {
                findAugPath();
                if(!finish) subX_addY();
            }
            Enlarge();
        }

        ll ans = 0;
        for(int i = 1; i <= n; i++)
        {
            if(c[i][l[i]] != OO) ans += c[i][l[i]];
            else l[i] = 0;
        }
        return isMax ? -ans : ans;
    }

    vector < array < ll, 3 > > get_edges()
    {
        vector < array < ll, 3 > > edges;
        for(int u = 1; u <= n; ++u) if(l[u]) edges.push_back({u, l[u], c[u][l[u]]});
        return edges;
    }
};



//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


