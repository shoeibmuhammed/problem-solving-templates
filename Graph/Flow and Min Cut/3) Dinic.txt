//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                                      Dinic                                        */
// Itâ€™s an improvement over Ford-Fulkerson and Edmonds-Karp, especially for dense networks or networks with large capacities.
// Time complexity is O(V^2 * E) for general graphs, while(sqrtl(V) * E) for unit capacity graphs.
// Often much faster in practice than Edmonds-Karp.
// A unit network is a network in which for any vertex except either incoming or outgoing edge is unique and has unit capacity.
//
//

struct Edge
{
    ll u, v, flow = 0, cap = 0;

    Edge(ll u, ll v): u(u), v(v) { }
    Edge(ll u, ll v, ll c): u(u), v(v), cap(c) { }

    ll rem() { return cap - flow; }
};

struct Dinic
{
    ll n, s, t, id = 1, flow = 0;
    vector < Edge > edges;
    vector < vector < ll > > graph;
    vector < ll > lvl, ptr;

    Dinic(ll n, ll src, ll sink): n(n), s(src), t(sink)
    {
        graph.assign(n + 1, {});
        ptr.assign(n + 1, {});
    }

    void addEdge(ll u, ll v, ll w = oo, ll undir = 0) // undir = 1 --> the edges are undirected
    {
        graph[u].push_back((ll)edges.size());
        edges.push_back(Edge(u, v, w)); // even

        graph[v].push_back((ll)edges.size());
        edges.push_back(Edge(v, u, w * undir)); // odd
    }

    void move()
    {
        while(bfs())
        {
            ptr.assign(n + 1, { });
            while(ll f = dfs(s)) flow += f;
        }
    }

    // ll flow()
    // {
    //     ll res = 0;
    //     while(bfs())
    //     {
    //         ptr.assign(n + 1, { });
    //         while(ll f = dfs(s)) res += f;
    //     }
    //     return res;
    // }

    bool bfs()
    {
        lvl.assign(n + 1, -1); lvl[s] = 0;
        queue < ll > q; q.push(s);

        while(!q.empty())
        {
            auto u = q.front(); q.pop();

            for(const auto &i: graph[u])
            {
                auto &[_, v, f, c] = edges[i];

                if(~lvl[v] || f == c) continue;

                lvl[v] = lvl[u] + 1;
                q.push(v);
            }
        }

        return lvl[t] != -1;
    }

    ll dfs(ll u, ll flow = oo)
    {
        if(u == t) return flow;

        if(!flow) return 0;

        for( ; ptr[u] < (ll)graph[u].size(); ptr[u]++)
        {
            ll i = graph[u][ptr[u]];
            auto [_, v, f, c] = edges[i];

            if((f == c) || (lvl[v] != lvl[u] + 1)) continue;

            ll bottleNeck = dfs(v, min(flow, c - f));

            if(!bottleNeck) continue;

            edges[i].flow += bottleNeck;
            edges[i ^ 1].flow -= bottleNeck;

            return bottleNeck;
        }

        return 0;
    }

    // get any set of edges to achieve the min cut (max flow)
    vector < array < ll, 2 > > getEdges()
    {
        vector < ll > srcSide(n + 1); srcSide[s] = 1;
        queue < ll > q; q.push(s);

        while(!q.empty())
        {
            ll u = q.front(); q.pop();

            for(const auto &i: graph[u])
            {
                auto &[_, v, f, c] = edges[i];
                if(!srcSide[v] && f != c) q.push(v), srcSide[v] = 1;
            }
        }

        vector < array < ll, 2 > > res;
        for(ll i = 0; i < (ll)edges.size(); i += 2)
        {
            auto &[u, v, f, c] = edges[i];
            if(srcSide[u] && !srcSide[v]) res.push_back({u, v});
        }

        return res;
    }
};



//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
