//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                                      Edmonds-Karp                                        */
// Is a specific implementation of the Ford-Fulkerson algorithm for computing maximum flow in a network.
// always chooses the shortest augmenting path (fewest edges) using BFS.
// Time complexity is O(V * E^2)
//

struct Edge
{
    ll u, v, flow = 0, cap = 0;

    Edge(ll u, ll v): u(u), v(v) { }
    Edge(ll u, ll v, ll c): u(u), v(v), cap(c) { }

    ll rem() { return cap - flow; }
};

struct EdmonKarp
{
    ll n, s, t, id = 1;
    vector < Edge > edges;
    vector < vector < ll > > graph;
    vector < ll > par;

    EdmonKarp(ll n, ll src, ll sink): n(n), s(src), t(sink)
    {
        graph.assign(n + 1, {});
    }

    void addEdge(ll u, ll v, ll w = oo, ll undir = 0) // undir = 1 --> the edges are undirected
    {
        graph[u].push_back((ll)edges.size());
        edges.push_back(Edge(u, v, w)); // even

        graph[v].push_back((ll)edges.size());
        edges.push_back(Edge(v, u, w * undir)); // odd
    }

    ll flow()
    {
        ll res = 0, flow;
        while((flow = bfs()))
        {
            res += flow;
            ll u = t;
            while(u != s)
            {
                edges[par[u]].flow += flow;
                edges[par[u] ^ 1].flow -= flow;
                u = edges[par[u]].u;
            }
        }
        return res;
    }

    bool bfs()
    {
        par.assign(n + 1, -1);
        queue < array < ll, 2 > > q;
        q.push({s, oo});

        while(!q.empty())
        {
            auto [u, flow] = q.front(); q.pop();

            if(u == t) return flow;

            for(const auto &i: graph[u])
            {
                auto &[_, v, f, c] = edges[i];

                if(~par[v] || !edges[i].rem()) continue;

                par[v] = i;
                q.push({v, min(flow, edges[i].rem())});
            }
        }

        return 0;
    }

    void getEdges()
    {
        vector < ll > vis(n + 1, 0); vis[s] = 1;
        queue < ll > q; q.push(s);

        while(!q.empty())
        {
            ll u = q.front(); q.pop();

            for(const auto &i : graph[u])
            {
                if(!vis[edges[i].v] && edges[i].rem())
                {
                    q.push(edges[i].v);
                    vis[edges[i].v] = 1;
                }
            }
        }

        for(ll i = 0; i < (ll)edges.size(); i += 2)
        {
            if(vis[edges[i].u] != vis[edges[i].v])
            {
                cout << edges[i].u << ' ' << edges[i].v << endl;
            }
        }

        return;
    }
};



//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
