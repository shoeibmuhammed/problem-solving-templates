//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                                      Ford-Fulkerson algorithm                                        */
// Is another classic algorithm for computing maximum flow in a flow network. It’s actually the predecessor to Dinic’s algorithm.
// Idea: Repeatedly find augmenting paths and push flow along them.
// Time complexity is O(E * MaxFlow)
//

struct Edge
{
    ll u, v, flow = 0, cap = 0;

    Edge(ll u, ll v): u(u), v(v) { }
    Edge(ll u, ll v, ll c): u(u), v(v), cap(c) { }

    ll rem() { return cap - flow; }
};

struct Ford
{
    ll n, s, t, id = 1;
    vector < Edge > edges;
    vector < vector < ll > > graph;
    vector < ll > vis;

    Ford(ll n, ll s, ll t) : n(n), s(s), t(t)
    {
        graph.assign(n + 1, { });
        vis.assign(n + 1, { });
    }

    void addEdge(ll u, ll v, ll w = oo, ll undir = 0) // undir = 1 --> the edges are undirected
    {
        graph[u].push_back((ll)edges.size());
        edges.push_back(Edge(u, v, w)); // even

        graph[v].push_back((ll)edges.size());
        edges.push_back(Edge(v, u, w * undir)); // odd
    }

    ll flow()
    {
        ll res = 0, flow;
        while((flow = dfs(s))) res += flow, id++;
        return res;
    }


    ll dfs(ll u, ll flow = oo)
    {
        if(u == t) return flow;

        vis[u] = id;

        for(const auto &i : graph[u])
        {
            if(vis[edges[i].v] != id && edges[i].rem())
            {
                ll bottleNeck = dfs(edges[i].v, min(flow, edges[i].rem()));
                edges[i].flow += bottleNeck;
                edges[i ^ 1].flow -= bottleNeck; // reverse edge
                if(bottleNeck) return bottleNeck;
            }
        }

        return 0;
    }
};



//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
