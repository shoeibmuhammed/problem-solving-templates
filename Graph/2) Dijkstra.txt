//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*                           Dijkstra                         */
// get shortest distance + path in a non-negative weighted graph.
// time complexitu is O((V + E) * log(V)).
// can avoid cycles.



struct point { ll node, cost; };
struct path { ll node, cost; };
struct cmp { bool operator()(path &a, path &b) { return a.cost > b.cost; } }; // sort by cost ascending

ll n, m;
vector < vector < point > > graph;
vector < ll > dist, parent;

void dijkstra(ll start, ll end = -1)
{
    parent.assign(n + 1, -1);
    dist.assign(n + 1, oo);


    priority_queue < path, vector < path >, cmp > pq;
    pq.push({start, 0});
    dist[start] = 0;
    parent[start] = 0;

    while(!pq.empty())
    {
        ll u = pq.top().node, c = pq.top().cost;
        pq.pop();

        if(dist[u] < c) continue;

        if(u == end) return;

        for(const auto &i : graph[u])
        {
            if(c + i.cost < dist[i.node])
            {
                dist[i.node] = c + i.cost;
                parent[i.node] = u;
                pq.push({i.node, dist[i.node]});
            }
        }
    }
}


void solve()
{

    cin >> n >> m;
    graph.assign(n + 1, vector < point > ());
    for(ll i = 1; i <= m; i++)
    {
        ll u, v, c; cin >> u >> v >> c;
        graph[u].push_back({v, c});
        graph[v].push_back({u, c});
    }

    dijkstra(1);

    for(ll i = 1; i <= n; i++) cout << dist[i] << ' ';
    cout << endl;


    for(ll i = 1; i <= n; i++)
    {
        if(parent[i] == -1) continue;
        vector < ll > road;
        ll curr = i;
        while(curr) { road.push_back(curr); curr = parent[curr]; }
        reverse(all(road));
        for(const auto &j : road) cout << j << ' ';
        cout << endl;
    }


    return;
}


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


