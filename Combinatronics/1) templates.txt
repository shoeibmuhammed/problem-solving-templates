//----------------------------------------------------------------------------------------------------------------


/*              fact, inv_fact, nCr, nPr                */
// precompute in O(2*N + log(mod)), answer in O(1)
// don't use int

const ll N = (ll)6e6 + 6;
ll fact[N], inv_fact[N];

ll mod_exp(ll x, ll n, ll m = mod) // O(log(n))
{
    ll res = 1;
    while(n)
    {
        if (n % 2) res = (((res % m) * (x % m)) % m);
        x = (((x % m) * (x % m)) % m);
        n /= 2;
    }
    return res;
}

ll mod_mul(ll x , ll y, ll m = mod) { return (((x % m) * (y % m)) % m); }
ll mod_inv(ll x, ll m = mod){ return mod_exp(x , m - 2, m); } // Fermat’s little theorem (m is a prime number)
ll mod_div(ll x, ll y, ll m = mod){ return mod_mul(x, mod_inv(y, m), m); }
ll mod_add(ll x, ll y, ll m = mod) { ll z = (x % m) + (y % m); z %= m; return z; }
ll mod_sub(ll x, ll y, ll m = mod) { ll z = (x % m) - (y % m); while(z < 0) z += m; z %= m; return z; }

void pre_compute(ll m = mod)
{
    // pre-process n! in O(N)
    fact[0] = 1;
    for (ll i = 1; i < N; i++)
        fact[i] = mod_mul(i, fact[i - 1], m);

    // pre-process (n!)^-1 in O(N + log(mod))
    inv_fact[N - 1] = mod_inv(fact[N - 1], m);
    for(ll i = N - 2; i >= 0; i--)
        inv_fact[i] = mod_mul((i + 1), inv_fact[i + 1], m);
}

ll npr(ll n, ll r, ll m = mod) // nPr = n!/(n - r)!
{
    if(r > n || min(r, n) < 0) return 0;
    return mod_mul(fact[n], inv_fact[n - r], m);
}

ll ncr(ll n, ll r, ll m = mod) // nCr = n!/((n - r)! * r!)
{
    if(r > n || min(r, n) < 0) return 0;
    return mod_mul(mod_mul(fact[n], inv_fact[r], m), inv_fact[n - r], m);
}

ll catalan(ll n) // catalan[n] = nCr(2n, n) / (n + 1)
{
    if(n <= 0 || n % 2) return 0;
    return mod_div(ncr(n, n/2), (n/2) + 1);
//    return mod_sub(ncr(n, n/2), ncr(n, (n/2) - 1));
}

ll starsANDbars(ll n, ll k, ll f = 1)
{

    if(f) // empty boxes
        return ncr(n + k - 1, k - 1);
    else // non-empty boxes
        return ncr(n - 1, k - 1);
}

pre_compute();


//----------------------------------------------------------------------------------------------------------------


// https://cp-algorithms.com/combinatorics/binomial-coefficients.html --> look at this later

// nCr = n!/((n - r)! * r!)

ll ncr(ll n, ll r)
{
    if (r > n || min(n, r) < 0) return 0;
    r = max(r, n - r);
    ll ans = 1, div = 1, i = r + 1;
    while (i <= n)
    {
//        ans *= i++; ans /= div++;
         ans = mod_mul(ans, i++); ans = mod_div(ans, div++);
    }
    return ans;
}

// very good when r is small
ll ncr(ll n, ll r)
{
    ll num = 1, den = 1;
    for (ll i = n; i > n - r; i--)
    {
        num = mod_mul(num, i);
        den = mod_mul(den, n - i + 1);
    }
    return mod_div(num, den);
}

// nPr = n!/(n - r)!
ll npr(ll n, ll r)
{
    if (r > n || min(n, r) < 0) return 0;
    ll ans = 1, i = n - r + 1;
    while (i <= n)
    {
//        ans *= i++;
        ans = mod_mul(ans, i++);
    }
    return ans;
}


//----------------------------------------------------------------------------------------------------------------


/*              Derangement of an array                */
// O(n * log(n))
// mx_freq <= (ll)n/2


ll n;
vector < ll > a, ans;

void derangement()
{
    ans.clear();

    map < ll, ll > freq;
    ll mx = 1;
    for(const auto &i : a)
    { freq[i]++; mx = max(mx, freq[i]); }

    if(mx > (ll)n/2) return;

    vector < pair < ll, ll >  > c;
    for(ll i = 0; i < n; i++)
        c.push_back({a[i], i});
    sort(all(c));

    vector < ll > d;
    for(ll i = n - mx; i < n; i++) d.push_back(c[i].first);
    for(ll i = 0; i < n - mx; i++) d.push_back(c[i].first);

    ans.assign(n, 0);
    for(ll i = 0; i < n; i++)
        ans[c[i].second] = d[i];

    return;
}


void solve()
{

    cin >> n;
    a.resize(n);
    for(auto &i : a) cin >> i;

    derangement();

    if(!ans.empty())
    {
        for(const auto &i : ans)
            cout << i << ' ';
        cout << endl;
    }
    else
    {
        // can't derangement the array
        ne;
    }


    return;
}


//-----------------------------------------------------------------------


/*              Burnside's lemma / Pólya enumeration theorem             */
// Is used for counting the number of different objects based on their symmetry.

// The no. of distinct necklaces of n stones, m colors, factor is the number of colors that each stone can have.
// (available movement is Rotation only) = sum[i=0->n-1]((m^(gcd(i, n)))^(factor)) / n
ll get_burnside_lemma_1(ll n, ll m, ll factor = 1)
{
    ll ans = 0;
    for(ll i = 0; i <= n - 1; i++)
        ans = mod_add(ans, mod_exp(mod_exp(m, gcd(i, n)), factor));
    ans = mod_div(ans, n);
    return ans;
}


//-----------------------------------------------------------------------

