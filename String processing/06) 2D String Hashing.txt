//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*              2D String Hashing               */
// check if two sub-board are equal or not!
// pre-processing in O(4*N), querying (comparing different sub-boards) in O(1)
// adjust base (29, 31, 37, 41, 137, 277), mod (127657753, 987654319, 998244353, 1e9 + 7, 1e9 + 9)
// https://vjudge.net/solution/57310680

// ....................

const ll N = (ll)2e6 + 6, base1 = 3731, base2 = 2999, mod3 = (ll)998244353; // 2 bases, 1 mod
const char _ref = 'a' - 1ll; // 'a', 'A', '0

// ....................

// Modular(Binary) Exponentiation: Quick calculation of ((x^n) mod m) in O(log(n))
ll mod_exp(ll x, ll n, ll m = mod)
{
    ll res = 1;
    while(n)
    {
        if (n % 2) res = (((res % m) * (x % m)) % m);
        x = (((x % m) * (x % m)) % m);
        n /= 2;
    }
    return res;
}

// Modular Arithmetic operations
ll mod_mul(ll x , ll y, ll m = mod) { return (((x % m) * (y % m)) % m); }
ll mod_inv(ll x, ll m = mod){ return mod_exp(x , m - 2, m); } // Fermatâ€™s little theorem (m is a prime number)
ll mod_div(ll x, ll y, ll m = mod){ return mod_mul(x, mod_inv(y, m), m); }
ll mod_add(ll x, ll y, ll m = mod) { ll z = (x % m) + (y % m); z %= m; return z; }
ll mod_sub(ll x, ll y, ll m = mod) { ll z = (x % m) - (y % m); while(z < 0) z += m; z %= m; return z; }

// ....................

ll pw1[N], pw2[N];
void pre_process()
{
    pw1[0] = pw2[0] = 1;
    for(ll i = 1; i < N; i++)
    {
        pw1[i] = mod_mul(pw1[i - 1], base1, mod3);
        pw2[i] = mod_mul(pw2[i - 1], base2, mod3);
    }
}

struct _Hash_2d
{
    ll n, m;
    vector < string > s;
    vector < vector < ll > > ht; // hash table

    _Hash_2d(vector < string > &_s)
    {
        s = _s;
        n = (ll)_s.size(); m = (ll)_s[0].size();
        ht.assign(n + 1, vector < ll > (m + 1, 0));
        _generate_hash_table();
    }

    void _generate_hash_table()
    {
        for(ll i = 0; i < n; i++)
            for(ll j = 0; j < m; j++)
                ht[i + 1][j + 1] = (ll)(s[i][j] - _ref);

        for(ll i = 0; i < n; i++)
            for(ll j = 0; j <= m; j++)
                ht[i + 1][j] = mod_add(ht[i + 1][j], mod_mul(ht[i][j], base1, mod3), mod3);

        for(ll i = 0; i <= n; i++)
            for(ll j = 0; j < m; j++)
                ht[i][j + 1] = mod_add(ht[i][j + 1], mod_mul(ht[i][j], base2, mod3), mod3);

    }

    ll _get_hash(ll x1, ll y1, ll x2, ll y2)
    {
        x1++; y1++; x2++; y2++; // convert to 1-indexed

        if(x1 < 1 || x1 > n || y1 < 1 || y1 > m) return -1;
        if(x2 < 1 || x2 > n || y2 < 1 || y2 > m) return -1;
        if(x1 > x2 || y1 > y2) return -1;

        ll dx = (x2 - x1 + 1), dy = (y2 - y1 + 1);

        x1--; y1--;

        // ret = (ht[x2][y2] - (ht[x2][y1] * pw2[dy])) - ((ht[x1][y2] - (ht[x1][y1] * pw2[dy])) * (pw1[dx]))
        ll ret = mod_sub(ht[x2][y2], mod_mul(ht[x2][y1], pw2[dy], mod3), mod3);
        ret = mod_sub(ret, mod_mul(mod_sub(ht[x1][y2], mod_mul(ht[x1][y1], pw2[dy], mod3), mod3), pw1[dx], mod3), mod3);
        return ret;
    }

};

// ....................

pre_process();


//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

