//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*              String Double Hashing               */
// pre-processing in O(N), querying (push, pop, compare whole range) in O(1)
// adjust base (29, 31, 37, 41, 137, 277), mod (127657753, 987654319, 998244353, 1e9 + 7, 1e9 + 9)
// if TLE --> Single Hashing

// ....................

const ll N = (ll)2e6 + 6, base1 = 31, base2 = 41, mod1 = (ll)127657753, mod2 = (ll)987654319;
const char _ref = 'a' - 1ll; // 'a', 'A', '0'

// ....................

// Modular(Binary) Exponentiation: Quick calculation of ((x^n) mod m) in O(log(n))
ll mod_exp(ll x, ll n, ll m = mod)
{
    ll res = 1;
    while(n)
    {
        if (n % 2) res = (((res % m) * (x % m)) % m);
        x = (((x % m) * (x % m)) % m);
        n /= 2;
    }
    return res;
}

// Modular Arithmetic operations
ll mod_mul(ll x , ll y, ll m = mod) { return (((x % m) * (y % m)) % m); }
ll mod_inv(ll x, ll m = mod){ return mod_exp(x , m - 2, m); } // Fermat’s little theorem (m is a prime number)
ll mod_div(ll x, ll y, ll m = mod){ return mod_mul(x, mod_inv(y, m), m); }
ll mod_add(ll x, ll y, ll m = mod) { ll z = (x % m) + (y % m); z %= m; return z; }
ll mod_sub(ll x, ll y, ll m = mod) { ll z = (x % m) - (y % m); while(z < 0) z += m; z %= m; return z; }

// ....................

ll inv1, inv2;
ll pw1[N], pw2[N];
void pre_process()
{
    inv1 = mod_inv(base1, mod1);
    inv2 = mod_inv(base2, mod2);
    pw1[0] = pw2[0] = 1;
    for(ll i = 1; i < N; i++)
    {
        pw1[i] = mod_mul(pw1[i - 1], base1, mod1);
        pw2[i] = mod_mul(pw2[i - 1], base2, mod2);
    }
}

struct _Hash
{
    ll hash_val1, hash_val2, len;
    deque < ll > dq;

    _Hash() { _clear(); }

    void _clear()
    {
        hash_val1 = hash_val2 = len = 0;
        dq.clear();
    }

    pair < ll, ll > get_hash() { return {hash_val1, hash_val2}; }

    bool operator == (const _Hash &hash2)
    { return ((hash_val1 == hash2.hash_val1) && (hash_val2 == hash2.hash_val2)); }

    void _push_back(char c) // push from right in O(1)
    {
        ll digit = (ll)(c - _ref);
        // h = (h * base) + (digit)
        hash_val1 = mod_add(mod_mul(hash_val1, base1, mod1), digit, mod1);
        hash_val2 = mod_add(mod_mul(hash_val2, base2, mod2), digit, mod2);
        dq.push_back(c); len++;
    }
    void _pop_back() // pop from right in O(1)
    {
        if(!len) return;
        ll digit = (ll)(dq.back() - _ref);
        // h = (h - digit) / (base)
        hash_val1 = mod_mul(mod_sub(hash_val1, digit, mod1), inv1, mod1);
        hash_val2 = mod_mul(mod_sub(hash_val2, digit, mod2), inv2, mod2);
        dq.pop_back(); len--;
    }
    void _push_front(char c) // push from left in O(1)
    {
        ll digit = (ll)(c - _ref);
        // h = (digit * (base ^ len)) + h
        hash_val1 = mod_add(mod_mul(digit, pw1[len], mod1), hash_val1, mod1);
        hash_val2 = mod_add(mod_mul(digit, pw2[len], mod2), hash_val2, mod2);
        dq.push_front(c); len++;
    }
    void _pop_front() // pop from left in O(1)
    {
        if(!len) return;
        ll digit = (ll)(dq.front() - _ref);
        // h = h – (digit * (base ^ len))
        hash_val1 = mod_sub(hash_val1, mod_mul(digit, pw1[len - 1ll], mod1), mod1);
        hash_val2 = mod_sub(hash_val2, mod_mul(digit, pw2[len - 1ll], mod2), mod2);
        dq.pop_front(); len--;
    }

};

// ....................

pre_process();


//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*              String Single Hashing               */
// pre-processing in O(N), querying (push, pop, compare whole range) in O(1)
// adjust base (29, 31, 37, 41, 137, 277), mod (127657753, 987654319, 998244353, 1e9 + 7, 1e9 + 9)
// if WA --> String Double Hashing

// ....................

const ll N = (ll)2e6 + 6, base1 = 31, mod1 = (ll)127657753;
const char _ref = 'a' - 1ll; // 'a', 'A', '0'

// ....................

// Modular(Binary) Exponentiation: Quick calculation of ((x^n) mod m) in O(log(n))
ll mod_exp(ll x, ll n, ll m = mod)
{
    ll res = 1;
    while(n)
    {
        if (n % 2) res = (((res % m) * (x % m)) % m);
        x = (((x % m) * (x % m)) % m);
        n /= 2;
    }
    return res;
}

// Modular Arithmetic operations
ll mod_mul(ll x , ll y, ll m = mod) { return (((x % m) * (y % m)) % m); }
ll mod_inv(ll x, ll m = mod){ return mod_exp(x , m - 2, m); } // Fermat’s little theorem (m is a prime number)
ll mod_div(ll x, ll y, ll m = mod){ return mod_mul(x, mod_inv(y, m), m); }
ll mod_add(ll x, ll y, ll m = mod) { ll z = (x % m) + (y % m); z %= m; return z; }
ll mod_sub(ll x, ll y, ll m = mod) { ll z = (x % m) - (y % m); while(z < 0) z += m; z %= m; return z; }

// ....................

ll inv1;
ll pow1[N];
void pre_process()
{
    inv1 = mod_inv(base1, mod1);
    pow1[0] = 1;
    for(ll i = 1; i < N; i++)
        pow1[i] = mod_mul(pow1[i - 1], base1, mod1);
}

struct _Hash
{
    ll hash_val1, len;
    deque < ll > dq;

    _Hash() { _clear(); }

    void _clear()
    {
        hash_val1 = len = 0;
        dq.clear();
    }

    ll get_hash() { return hash_val1; }

    bool operator == (const _Hash &hash2)
    { return (hash_val1 == hash2.hash_val1); }

    void _push_back(char c) // push from right in O(1)
    {
        ll digit = (ll)(c - _ref);
        // h = (h * base) + (digit)
        hash_val1 = mod_add(mod_mul(hash_val1, base1, mod1), digit, mod1);
        dq.push_back(c); len++;
    }
    void _pop_back() // pop from right in O(1)
    {
        if(!len) return;
        ll digit = (ll)(dq.back() - _ref);
        // h = (h - digit) / (base)
        hash_val1 = mod_mul(mod_sub(hash_val1, digit, mod1), inv1, mod1);
        dq.pop_back(); len--;
    }
    void _push_front(char c) // push from left in O(1)
    {
        ll digit = (ll)(c - _ref);
        // h = (digit * (base ^ len)) + h
        hash_val1 = mod_add(mod_mul(digit, pow1[len], mod1), hash_val1, mod1);
        dq.push_front(c); len++;
    }
    void _pop_front() // pop from left in O(1)
    {
        if(!len) return;
        ll digit = (ll)(dq.front() - _ref);
        // h = h – (digit * (base ^ len))
        hash_val1 = mod_sub(hash_val1, mod_mul(digit, pow1[len - 1ll], mod1), mod1);
        dq.pop_front(); len--;
    }

};

// ....................

pre_process();


//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

