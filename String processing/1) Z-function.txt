//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*              Z-function             */
// calcuate the z-values for all string in O(n).
// z[i] is the length of the longest prefix substring starting at s[i..] which is also a prefix of s[0..].
// z[i] <= (n - i), s[0..z[i][ == s[i..i+z[i][, ...
// the first entry of Z array is meaning less as complete string is always prefix of itself, so z[0] = 0.
// usefull for string matching (s = s + '#' + t), u can replace the string with a vector of numbers, ...
// s + '?' + t, t + '?' + s, rev(s) + '?' + t, rev(t) + '?' + s, ...


// calculate the z-array in O(n).
vector < ll > z_function(string s)
{
    ll n = (ll)s.size();
    vector < ll > z(n, 0);

    ll l = 0, r = 0; // [l, r[ is the rightmost segment match.
    for(ll i = 1; i < n; i++)
    {
        if(i < r) z[i] = min(z[i - l], r - i); // use the z-value of previous similar character as an initial start.

        while(i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;

        if(i + z[i] > r) l = i, r = i + z[i];
    }

    return z;
}


// find the patterns of string t(m) in string s(n) in O(n).
vector < ll > get_matches(string s, string t)
{
    ll n = (ll)s.size(), m = (ll)t.size();
    t = t + '#' + s;
    vector < ll > z = z_function(t);

    vector < ll > matches;
    for(ll i = m + 1; i < n + m + 1; i++)
    {
        if(z[i] == m)
        {
            matches.push_back(i - (m + 1));
        }

    }

    return matches;
}


// convert z-array to pi-array in O(n).
vector < ll > z_to_pi(vector < ll > z)
{
    ll n = (ll)z.size();
    vector < ll > pi(n, 0);

    for(ll i = 1; i < n; i++) pi[i + z[i] - 1] = max(pi[i + z[i] - 1], z[i]);
    for(ll i = n - 2; i >= 0; i--) pi[i] = max(pi[i + 1] - 1, pi[i]);

    return pi;
}


// find the max length suffix palindrome substring using z-array in O(n).
ll max_right_palindrome(string s)
{
    ll n = (ll)s.size();

    string k = s;
    reverse(all(k));
    k = k + '#' + s;
    vector < ll > z = z_function(k);

    for(ll i = n + 1; i < 2*n + 1; i++)
    {
        if(z[i] == (2*n + 1) - i)
        {
            return z[i];
        }
    }

    return 1;
}


// find the max length prefix palindrome substring using z-array in O(n).
ll max_left_palindrome(string s)
{
    ll n = (ll)s.size();

    string k = s;
    reverse(all(k));
    k = s + '#' + k;
    vector < ll > z = z_function(k);

    for(ll i = n + 1; i < 2*n + 1; i++)
    {
        if(z[i] == (2*n + 1) - i)
        {
            return z[i];
        }
    }

    return 1;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

