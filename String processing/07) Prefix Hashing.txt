//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// https://codeforces.com/contest/2069/submission/306762374

/*              Prefix String Double Hashing (with struct)               */
// pre-processing in O(N), querying (comparing different ranges) in O(1)
// weights: 0 1 2 ... (n - 1)
// if TLE --> (without struct), or (Single Hashing)
// adjust base (29, 31, 37, 41, 137, 277), mod (127657753, 987654319, 998244353, 1e9 + 7, 1e9 + 9)

// ....................

const ll N = (ll)2e6 + 6, base1 = 31, base2 = 41, mod1 = (ll)127657753, mod2 = (ll)987654319;
const char _ref = 'a' - 1ll; // 'a', 'A', '0'

// ....................

// Modular(Binary) Exponentiation: Quick calculation of ((x^n) mod m) in O(log(n))
ll mod_exp(ll x, ll n, ll m = mod)
{
    ll res = 1;
    while(n)
    {
        if (n % 2) res = (((res % m) * (x % m)) % m);
        x = (((x % m) * (x % m)) % m);
        n /= 2;
    }
    return res;
}

// Modular Arithmetic operations
ll mod_mul(ll x , ll y, ll m = mod) { return (((x % m) * (y % m)) % m); }
ll mod_inv(ll x, ll m = mod){ return mod_exp(x , m - 2, m); } // Fermat’s little theorem (m is a prime number)
ll mod_div(ll x, ll y, ll m = mod){ return mod_mul(x, mod_inv(y, m), m); }
ll mod_add(ll x, ll y, ll m = mod) { ll z = (x % m) + (y % m); z %= m; return z; }
ll mod_sub(ll x, ll y, ll m = mod) { ll z = (x % m) - (y % m); while(z < 0) z += m; z %= m; return z; }

// ....................

ll pw1[N], pw2[N], inv1[N], inv2[N];
void pre_process()
{
    ll inv1_val = mod_inv(base1, mod1), inv2_val = mod_inv(base2, mod2);

    pw1[0] = pw2[0] = inv1[0] = inv2[0] = 1;
    for(ll i = 1; i < N; i++)
    {
        pw1[i] = mod_mul(pw1[i - 1], base1, mod1);
        pw2[i] = mod_mul(pw2[i - 1], base2, mod2);

        inv1[i] = mod_mul(inv1[i - 1], inv1_val, mod1);
        inv2[i] = mod_mul(inv2[i - 1], inv2_val, mod2);
    }
}

struct _pre_hash
{
    ll n;
    string s;
    vector < pair < ll, ll > > _pre, _pre_rev;

    _pre_hash(string _s)
    {
       s = _s;
       n = (ll)s.size();
       _generate_pre();
    }

    void _generate_pre()
    {
        _pre.resize(n); _pre_rev.resize(n);
        for (ll i = 0; i < n; i++) // 0 1 2 ... (n - 1)
        {
            ll digit1 = (ll)(s[i] - _ref);

            _pre[i].first = (i ? _pre[i - 1].first : 0);
            _pre[i].first = mod_add(_pre[i].first, mod_mul(digit1, pw1[i], mod1), mod1);

            _pre[i].second = (i ? _pre[i - 1].second : 0);
            _pre[i].second = mod_add(_pre[i].second, mod_mul(digit1, pw2[i], mod2), mod2);

            // ...

            ll digit2 = (ll)(s[n - 1 - i] - _ref);

            _pre_rev[i].first = (i ? _pre_rev[i - 1].first : 0);
            _pre_rev[i].first = mod_add(_pre_rev[i].first, mod_mul(digit2, pw1[i], mod1), mod1);

            _pre_rev[i].second = (i ? _pre_rev[i - 1].second : 0);
            _pre_rev[i].second = mod_add(_pre_rev[i].second, mod_mul(digit2, pw2[i], mod2), mod2);
        }
    }

    pair < ll, ll > _get_range(ll l, ll r)
    {
        if(l > r) return {0, 0};

        ll len = (r - l + 1);

        pair < ll, ll > val = {_pre[r].first, _pre[r].second};
        if (l > 0)
        {
            val.first = mod_sub(val.first, _pre[l - 1].first, mod1);
            val.second = mod_sub(val.second, _pre[l - 1].second, mod2);
        }
        val.first = mod_mul(val.first, inv1[l], mod1);
        val.second = mod_mul(val.second, inv2[l], mod2);

        return val;
    }

    pair < ll, ll > _get_range_rev(ll l, ll r)
    {
        if(l > r) return {0, 0};

        ll len = (r - l + 1);

        pair < ll, ll > val = {_pre_rev[r].first, _pre_rev[r].second};
        if (l > 0)
        {
            val.first = mod_sub(val.first, _pre_rev[l - 1].first, mod1);
            val.second = mod_sub(val.second, _pre_rev[l - 1].second, mod2);
        }
        val.first = mod_mul(val.first, inv1[l], mod1);
        val.second = mod_mul(val.second, inv2[l], mod2);

        return val;
    }

    bool is_pal(ll l, ll r)
    {
        return _get_range(l, r) == _get_range_rev(n - 1 - r, n - 1 - l);
    }

};

// ....................

pre_process();


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*              Prefix String Double Hashing (without struct)               */
// pre-processing in O(N), querying (comparing different ranges) in O(1)
// weights: 0 1 2 ... (n - 1)
// faster than (with struct)
// adjust base (29, 31, 37, 41, 137, 277), mod (127657753, 987654319, 998244353, 1e9 + 7, 1e9 + 9)

// ....................

const ll N = (ll)2e6 + 6, base1 = 31, base2 = 41, mod1 = (ll)127657753, mod2 = (ll)987654319;
const char _ref = 'a' - 1ll; // 'a', 'A', '0'

// ....................

// Modular(Binary) Exponentiation: Quick calculation of ((x^n) mod m) in O(log(n))
ll mod_exp(ll x, ll n, ll m = mod)
{
    ll res = 1;
    while(n)
    {
        if (n % 2) res = (((res % m) * (x % m)) % m);
        x = (((x % m) * (x % m)) % m);
        n /= 2;
    }
    return res;
}

// Modular Arithmetic operations
ll mod_mul(ll x , ll y, ll m = mod) { return (((x % m) * (y % m)) % m); }
ll mod_inv(ll x, ll m = mod){ return mod_exp(x , m - 2, m); } // Fermat’s little theorem (m is a prime number)
ll mod_div(ll x, ll y, ll m = mod){ return mod_mul(x, mod_inv(y, m), m); }
ll mod_add(ll x, ll y, ll m = mod) { ll z = (x % m) + (y % m); z %= m; return z; }
ll mod_sub(ll x, ll y, ll m = mod) { ll z = (x % m) - (y % m); while(z < 0) z += m; z %= m; return z; }

// ....................

ll pw1[N], pw2[N], inv1[N], inv2[N];
void pre_process()
{
    ll inv1_val = mod_inv(base1, mod1), inv2_val = mod_inv(base2, mod2);

    pw1[0] = pw2[0] = inv1[0] = inv2[0] = 1;
    for(ll i = 1; i < N; i++)
    {
        pw1[i] = mod_mul(pw1[i - 1], base1, mod1);
        pw2[i] = mod_mul(pw2[i - 1], base2, mod2);

        inv1[i] = mod_mul(inv1[i - 1], inv1_val, mod1);
        inv2[i] = mod_mul(inv2[i - 1], inv2_val, mod2);
    }
}

pair < ll, ll > _pre[N], _pre_rev[N];

void _generate_pre(string &s)
{
    ll n = (ll)s.size();

    for (ll i = 0; i < n; i++) // 0 1 2 ... (n - 1)
    {
        ll digit1 = (ll)(s[i] - _ref);

        _pre[i].first = (i ? _pre[i - 1].first : 0);
        _pre[i].first = mod_add(_pre[i].first, mod_mul(digit1, pw1[i], mod1), mod1);

        _pre[i].second = (i ? _pre[i - 1].second : 0);
        _pre[i].second = mod_add(_pre[i].second, mod_mul(digit1, pw2[i], mod2), mod2);

        // ...

        ll digit2 = (ll)(s[n - 1 - i] - _ref);

        _pre_rev[i].first = (i ? _pre_rev[i - 1].first : 0);
        _pre_rev[i].first = mod_add(_pre_rev[i].first, mod_mul(digit2, pw1[i], mod1), mod1);

        _pre_rev[i].second = (i ? _pre_rev[i - 1].second : 0);
        _pre_rev[i].second = mod_add(_pre_rev[i].second, mod_mul(digit2, pw2[i], mod2), mod2);
    }
}

pair < ll, ll > _get_range(ll l, ll r)
{
    if(l > r) return {0, 0};

    ll len = (r - l + 1);

    pair < ll, ll > val = {_pre[r].first, _pre[r].second};
    if (l > 0)
    {
        val.first = mod_sub(val.first, _pre[l - 1].first, mod1);
        val.second = mod_sub(val.second, _pre[l - 1].second, mod2);
    }
    val.first = mod_mul(val.first, inv1[l], mod1);
    val.second = mod_mul(val.second, inv2[l], mod2);

    return val;
}

pair < ll, ll > _get_range_rev(ll l, ll r)
{
    if(l > r) return {0, 0};

    ll len = (r - l + 1);

    pair < ll, ll > val = {_pre_rev[r].first, _pre_rev[r].second};
    if (l > 0)
    {
        val.first = mod_sub(val.first, _pre_rev[l - 1].first, mod1);
        val.second = mod_sub(val.second, _pre_rev[l - 1].second, mod2);
    }
    val.first = mod_mul(val.first, inv1[l], mod1);
    val.second = mod_mul(val.second, inv2[l], mod2);

    return val;
}

bool is_pal(ll l, ll r, ll n)
{
    return _get_range(l, r) == _get_range_rev(n - 1 - r, n - 1 - l);
}

// ....................

pre_process();


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*              Prefix String Single Hashing (with struct)               */
// pre-processing in O(N), querying (comparing different ranges) in O(1)
// weights: 0 1 2 ... (n - 1)
// if WA --> (Double Hashing), TLE --> (without struct)
// adjust base (29, 31, 37, 41, 137, 277), mod (127657753, 987654319, 998244353, 1e9 + 7, 1e9 + 9)

// ....................

const ll N = (ll)2e6 + 6, base1 = 31, mod1 = (ll)127657753;
const char _ref = 'a' - 1ll; // 'a', 'A', '0'

// ....................

// Modular(Binary) Exponentiation: Quick calculation of ((x^n) mod m) in O(log(n))
ll mod_exp(ll x, ll n, ll m = mod)
{
    ll res = 1;
    while(n)
    {
        if (n % 2) res = (((res % m) * (x % m)) % m);
        x = (((x % m) * (x % m)) % m);
        n /= 2;
    }
    return res;
}

// Modular Arithmetic operations
ll mod_mul(ll x , ll y, ll m = mod) { return (((x % m) * (y % m)) % m); }
ll mod_inv(ll x, ll m = mod){ return mod_exp(x , m - 2, m); } // Fermat’s little theorem (m is a prime number)
ll mod_div(ll x, ll y, ll m = mod){ return mod_mul(x, mod_inv(y, m), m); }
ll mod_add(ll x, ll y, ll m = mod) { ll z = (x % m) + (y % m); z %= m; return z; }
ll mod_sub(ll x, ll y, ll m = mod) { ll z = (x % m) - (y % m); while(z < 0) z += m; z %= m; return z; }

// ....................

ll pw1[N], inv1[N];
void pre_process()
{
    ll inv1_val = mod_inv(base1, mod1);

    pw1[0] = inv1[0] = 1;
    for(ll i = 1; i < N; i++)
    {
        pw1[i] = mod_mul(pw1[i - 1], base1, mod1);

        inv1[i] = mod_mul(inv1[i - 1], inv1_val, mod1);
    }
}

struct _pre_hash
{
    ll n;
    string s;
    vector < ll > _pre, _pre_rev;

    _pre_hash(string _s)
    {
       s = _s;
       n = (ll)s.size();
       _generate_pre();
    }

    void _generate_pre()
    {
        _pre.resize(n); _pre_rev.resize(n);
        for (ll i = 0; i < n; i++) // 0 1 2 ... (n - 1)
        {
            ll digit1 = (ll)(s[i] - _ref);

            _pre[i] = (i ? _pre[i - 1] : 0);
            _pre[i] = mod_add(_pre[i], mod_mul(digit1, pw1[i], mod1), mod1);

            // ...

            ll digit2 = (ll)(s[n - 1 - i] - _ref);

            _pre_rev[i] = (i ? _pre_rev[i - 1] : 0);
            _pre_rev[i] = mod_add(_pre_rev[i], mod_mul(digit2, pw1[i], mod1), mod1);
        }
    }

    ll _get_range(ll l, ll r)
    {
        if(l > r) return {0, 0};

        ll len = (r - l + 1);

        ll val = _pre[r];
        if (l > 0) val = mod_sub(val, _pre[l - 1], mod1);
        val = mod_mul(val, inv1[l], mod1);

        return val;
    }

    ll _get_range_rev(ll l, ll r)
    {
        if(l > r) return {0, 0};

        ll len = (r - l + 1);

        ll val = _pre_rev[r];
        if (l > 0) val = mod_sub(val, _pre_rev[l - 1], mod1);
        val = mod_mul(val, inv1[l], mod1);

        return val;
    }

    bool is_pal(ll l, ll r)
    {
        return _get_range(l, r) == _get_range_rev(n - 1 - r, n - 1 - l);
    }

};

// ....................

pre_process();


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*              Prefix String Single Hashing (without struct)               */
// pre-processing in O(N), querying (comparing different ranges) in O(1)
// weights: 0 1 2 ... (n - 1)
// faster than (with struct), if WA --> (Double Hashing)
// adjust base (29, 31, 37, 41, 137, 277), mod (127657753, 987654319, 998244353, 1e9 + 7, 1e9 + 9)

// ....................

const ll N = (ll)2e6 + 6, base1 = 31, mod1 = (ll)127657753;
const char _ref = 'a' - 1ll; // 'a', 'A', '0'

// ....................

// Modular(Binary) Exponentiation: Quick calculation of ((x^n) mod m) in O(log(n))
ll mod_exp(ll x, ll n, ll m = mod)
{
    ll res = 1;
    while(n)
    {
        if (n % 2) res = (((res % m) * (x % m)) % m);
        x = (((x % m) * (x % m)) % m);
        n /= 2;
    }
    return res;
}

// Modular Arithmetic operations
ll mod_mul(ll x , ll y, ll m = mod) { return (((x % m) * (y % m)) % m); }
ll mod_inv(ll x, ll m = mod){ return mod_exp(x , m - 2, m); } // Fermat’s little theorem (m is a prime number)
ll mod_div(ll x, ll y, ll m = mod){ return mod_mul(x, mod_inv(y, m), m); }
ll mod_add(ll x, ll y, ll m = mod) { ll z = (x % m) + (y % m); z %= m; return z; }
ll mod_sub(ll x, ll y, ll m = mod) { ll z = (x % m) - (y % m); while(z < 0) z += m; z %= m; return z; }

// ....................

ll pw1[N], inv1[N];
void pre_process()
{
    ll inv1_val = mod_inv(base1, mod1);

    pw1[0] = inv1[0] = 1;
    for(ll i = 1; i < N; i++)
    {
        pw1[i] = mod_mul(pw1[i - 1], base1, mod1);

        inv1[i] = mod_mul(inv1[i - 1], inv1_val, mod1);
    }
}

ll _pre[N], _pre_rev[N];

void _generate_pre(string &s)
{
    ll n = (ll)s.size();

    for (ll i = 0; i < n; i++) // 0 1 2 ... (n - 1)
    {
        ll digit1 = (ll)(s[i] - _ref);

        _pre[i] = (i ? _pre[i - 1] : 0);
        _pre[i] = mod_add(_pre[i], mod_mul(digit1, pw1[i], mod1), mod1);

        // ...

        ll digit2 = (ll)(s[n - 1 - i] - _ref);

        _pre_rev[i] = (i ? _pre_rev[i - 1] : 0);
        _pre_rev[i] = mod_add(_pre_rev[i], mod_mul(digit2, pw1[i], mod1), mod1);
    }
}

ll _get_range(ll l, ll r)
{
    if(l > r) return {0, 0};

    ll len = (r - l + 1);

    ll val = _pre[r];
    if (l > 0) val = mod_sub(val, _pre[l - 1], mod1);
    val = mod_mul(val, inv1[l], mod1);

    return val;
}

ll _get_range_rev(ll l, ll r)
{
    if(l > r) return {0, 0};

    ll len = (r - l + 1);

    ll val = _pre_rev[r];
    if (l > 0) val = mod_sub(val, _pre_rev[l - 1], mod1);
    val = mod_mul(val, inv1[l], mod1);

    return val;
}

bool is_pal(ll l, ll r, ll n)
{
    return _get_range(l, r) == _get_range_rev(n - 1 - r, n - 1 - l);
}

// ....................

pre_process();


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

