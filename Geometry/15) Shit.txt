//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



// minimum distance from point c to line through a and b
ld dist_from_point_to_line(cld a, cld b, cld c)
{
    return fabsl(cross(b - a, c - a) / abs(b - a));
}

// computes the area and perimeter of the minimum enclosing rectangle of points
pair < ld, ld > minimumEnclosingRectangle(vector < cld > &p) // p in CCW
{
    ll n = p.size();

    if(n < 3)
    {
        ld d = 0;
        for(ll i = 0; i < n; i++) d += abs(p[i] - p[(i + 1) % n]);
        return {0, d};
    }

    ll mndot = 0;
    ld tmp = dot(p[1] - p[0], p[0]);
    for(ll i = 1; i < n; i++)
    {
        if(sgn(dot(p[1] - p[0], p[i]) - tmp) <= 0)
        {
            tmp = dot(p[1] - p[0], p[i]);
            mndot = i;
        }
    }

    ld perim = 1e18, area = 1e18;
    ll i = 0, j = 1, mxdot = 1;
    while(i < n)
    {
        cld cur = p[(i + 1) % n] - p[i];
        while(sgn(cross(cur, p[(j + 1) % n] - p[j])) >= 0) j = (j + 1) % n;
        while(sgn(dot(p[(mxdot + 1) % n], cur) - dot(p[mxdot], cur)) >= 0) mxdot = (mxdot + 1) % n;
        while(0 <= sgn(dot(p[mndot], cur) - dot(p[(mndot + 1) % n], cur))) mndot = (mndot + 1) % n;

        ld w = (dot(p[mxdot], cur) / abs(cur)) - (dot(p[mndot], cur) / abs(cur));
        ld h = dist_from_point_to_line(p[i], p[(i + 1) % n], p[j]);
        perim = min(perim, 2.0 * (w + h));
        area = min(area, w * h);
        i++;
    }

    return {area, perim};
}



//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


