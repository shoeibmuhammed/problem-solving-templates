//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



// determine the sign of the value
ll sgn(ld val) { return (val > eps) - (val < -eps); }

// cross product: v x w = |v| * |w| * sinÎ¸ = v.X*w.Y - v.Y*w.X
T cross(cld v, cld w) { return v.X*w.Y - v.Y*w.X; }



/*                              Rotating Calipers                              */
//
// what can it do?
//
// (1) the diameter of a polygon
// the diameter of a polygon is the maximum distance between any pair of antipodal points
//
// (2) the maximum distance between any two points --> get convex hull of the points + diameter of the polygon
//
// (3) the width of the polygon
// the width is: the minimum distance between two parallel lines that sandwich (enclose) the entire polygon, where the lines are parallel
//
// (4) the maximum distance between two polygons (not sure)
//


//............................................................................................

// enumerates all antipodal pairs of a convex polygon (via rotating calipers technique)
// return indicies of the points
vector < pair < ll, ll > > antiPodal(vector < cld > &p) // p in CW or CCW
{
    ll n = (ll)p.size();

    vector < pair < ll, ll > > result;
    if(n < 3) return result;

    auto nx = [&](int i){return (i + 1) % n;};
    auto pv = [&](int i){return (i - 1 + n) % n;};

    // parallel edges should't be visited twice
    vector < bool > vis(n, false);

    for (ll p1 = 0, p2 = 0; p1 < n; p1++)
    {
        // the edge that we are going to consider in this iteration
        // the datatype is Point, but it acts as a vector
        cld base = p[nx(p1)] - p[p1];

        // the last condition makes sure that the cross products don't have the same sign
        while(p2 == p1 || p2 == nx(p1) || sgn(cross(base, p[nx(p2)] - p[p2])) == sgn(cross(base, p[p2] - p[pv(p2)]))) p2 = nx(p2);

        if(vis[p1]) continue;
        vis[p1] = true;


        // segment [p1 .. nx(p1)] --> p2
        result.push_back({p1, p2});
        result.push_back({nx(p1), p2});

        // if both edges from p1 and p2 are parallel to each other
        if(sgn(cross(base, p[nx(p2)] - p[p2])) == 0)
        {
            // segment [p1 .. nx(p1)] --> segment [p2 .. nx(p2)]
            result.push_back({p1, nx(p2)});
            result.push_back({nx(p1), nx(p2)});
            vis[p2] = true;
        }
    }

    return result;
}

//............................................................................................

// (2) get the maximum distance between two points
vector < cld > hull = convexHull(p);
if((ll)hull.size() < 2) { cout << 0 << endl; return; }
if((ll)hull.size() == 2) { cout << abs(hull[1] - hull[0]) << endl; return; }
vector < pair < ll, ll > > antiPairs = antiPodal(hull);
ld res = 0;
for(const auto &i : antiPairs) res = max(res, abs(hull[i.first] - hull[i.second]));
cout << res << endl;

//............................................................................................

// (3) get the width of a polygon
ld polygonWidth(vector < cld > &p)
{
    ll n = (ll)p.size();
    if(n < 3) return 0;
    ld res = oo;

    auto nx = [&](int i){return (i + 1) % n;};
    auto pv = [&](int i){return (i - 1 + n) % n;};

    // parallel edges should't be visited twice
    vector < bool > vis(n, false);

    for (ll p1 = 0, p2 = 0; p1 < n; p1++)
    {
        // the edge that we are going to consider in this iteration
        // the datatype is Point, but it acts as a vector
        cld base = p[nx(p1)] - p[p1];

        // the last condition makes sure that the cross products don't have the same sign
        while(p2 == p1 || p2 == nx(p1) || sgn(cross(base, p[nx(p2)] - p[p2])) == sgn(cross(base, p[p2] - p[pv(p2)]))) p2 = nx(p2);

        if(vis[p1]) continue;
        vis[p1] = true;

        // segment [p1 .. nx(p1)] --> p2
        res = min(res, pointSegmentDist(p[p1], p[nx(p1)], p[p2]));

        // if both edges from p1 and p2 are parallel to each other
        if(sgn(cross(base, p[nx(p2)] - p[p2])) == 0)
        {
            // segment [p1 .. nx(p1)] --> segment [p2 .. nx(p2)]
            res = min(res, segmentSegmentDist(p[p1], p[nx(p1)], p[p2], p[nx(p2)]));
            vis[p2] = true;
        }
    }

    return res;
}

//............................................................................................

// (4) maximum distance from a convex polygon to another convex polygon
double maximum_dist_from_polygon_to_polygon(vector<PT> &u, vector<PT> &v){ //O(n)
    int n = (int)u.size(), m = (int)v.size();
    double ans = 0;
    if (n < 3 || m < 3) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) ans = max(ans, dist2(u[i], v[j]));
        }
        return sqrt(ans);
    }
    if (u[0].x > v[0].x) swap(n, m), swap(u, v);
    int i = 0, j = 0, step = n + m + 10;
    while (j + 1 < m && v[j].x < v[j + 1].x) j++ ;
    while (step--) {
        if (cross(u[(i + 1)%n] - u[i], v[(j + 1)%m] - v[j]) >= 0) j = (j + 1) % m;
        else i = (i + 1) % n;
        ans = max(ans, dist2(u[i], v[j]));
    }
    return sqrt(ans);
}

//............................................................................................

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


