//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                              Sweep Line                              */
//
//
//



//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                  Closest Pair of Points in O(n * log(n))                  */
// get the minimum euclidean distance between two points



void solve()
{

    ll n; cin >> n;
    vector < cld > p(n);
    for(ll i = 0; i < n; i++)
    {
        ll x, y; cin >> x >> y;
        p[i] = {x, y};
    }

    sort(all(p), [&](cld &pt1, cld &pt2) -> bool { return pt1.X < pt2.X; }); // sort x in ascending order

    set < array < ll, 2 > > window;


    ld res = OO;

    for(ll i = 0, j = 0; i < n; i++)
    {
        while(j < n && (p[i].X - p[j].X) > res)
        {
            window.erase({(ll)p[j].Y, (ll)p[j].X});
            j++;
        }

        auto st = window.lower_bound({p[i].Y - res, -OO});
        auto en = window.lower_bound({p[i].Y + res, -OO});


        if(en != window.end()) en++;

        while(st != en)
        {
            cld pt = {(*st)[1], (*st)[0]};
            res = min(res, abs(p[i] - pt));
            st++;
        }


        window.insert({(ll)p[i].Y, (ll)p[i].X});
    }

    cout << res << endl;


    return;
}



//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



// Given n rectangles, your task is to determine the total area of their union in O(n * log(n)).
struct Node
{

    // get variables

    ll mn, freq;

    ll lazy; // take care of initial value (may be changed to non-zero value!) --> modified in propagation also!
    bool is_lazy;


    Node() // neutral --> used in constructor, init, set, get(can be modified there! --> take care of it!)
    {
        mn = oo; freq = 0;

        lazy = 0;
        is_lazy = 0;
    }

    Node(ll x)
    {
        mn = x; freq = 1;

        lazy = 0;
        is_lazy = 0;
    }


    // set operation (remeber [lx, rx[ !)
    void change(ll x, ll lx, ll rx) // change or modify (sm like lazy!)
    {
        // if i have (r - l) child nodes, and all modified (apply set type operations) by x --> what should be my new value as their parent (get value)?  (segment tree store get!!)

        mn += x;
        lazy += x;

        is_lazy = 1;
    }

};


struct segTree
{

    ll leaf_size, tree_size;
    vector < Node > segData;

    segTree(ll n)
    {
        leaf_size = 1;
        while(leaf_size < n) leaf_size *= 2;
        tree_size = 2 * leaf_size;
        segData.resize(tree_size, Node());
    }




    // what we do on each two adjacent nodes to get their parent in O(1) --> modifiable!
    Node merge(Node &lf, Node &ri)
    {
        Node ans = Node();


        // operations to get ans (parent) node
        ans.mn = min(lf.mn, ri.mn);
        ans.freq = 0;
        if(ans.mn == lf.mn) ans.freq += lf.freq;
        if(ans.mn == ri.mn) ans.freq += ri.freq;


        return ans;
    }




    // Propagation in O(1)
    void propagete(ll ni, ll lx, ll rx)
    {
        if(rx - lx == 1 || segData[ni].is_lazy == 0) return;

        ll mid = (lx + rx) / 2;
        segData[2*ni + 1].change(segData[ni].lazy, lx, mid);
        segData[2*ni + 2].change(segData[ni].lazy, mid, rx);

        segData[ni].lazy = 0;  // modifiable!
        segData[ni].is_lazy = 0;
    }




    // initialization with values in O(n)
    void init(vector < ll > &a, ll ni, ll lx, ll rx)
    {
        if(rx - lx == 1)
        {
            if(lx < (ll)a.size())
                segData[ni] = Node(a[lx]);
            else
                segData[ni] = Node();
            return;
        }

        ll mid = (lx + rx) / 2;
        init(a, 2*ni + 1, lx, mid);
        init(a, 2*ni + 2, mid, rx);

        segData[ni] = merge(segData[2*ni + 1], segData[2*ni + 2]);
    }
    void init(vector < ll > &a) { init(a, 0, 0, leaf_size); }




    // set node/range in O(logn)
    void set(ll l, ll r, ll val, ll ni, ll lx, ll rx) // 0-indexed, [lx, rx[
    {
        propagete(ni, lx, rx);

        if(lx >= r || rx <= l) return;  // no intersection --> useless node & it's childs

        if(l <= lx && rx <= r) // all segments in --> take it
        {
            segData[ni].change(val, lx, rx);
            return;
        }

        // intersection --> dive deeper
        ll mid = (lx + rx) / 2;

        set(l, r, val, 2*ni + 1, lx, mid);
        set(l, r, val, 2*ni + 2, mid, rx);

        segData[ni] = merge(segData[2*ni + 1], segData[2*ni + 2]);
    }
    void set_range(ll l, ll r, ll val) { set(l, r, val, 0, 0, leaf_size); }
    void set_node(ll idx, ll val) { set(idx, idx + 1, val, 0, 0, leaf_size); }





    // get node/range in O(2*logn)
    Node get(ll l, ll r, ll ni, ll lx, ll rx) // 0-indexed, [lx, rx[
    {
        propagete(ni, lx, rx);

        if(lx >= r || rx <= l) // no intersection --> useless node & it's childs --> return neutral
            return Node(); // default neutral when getting      -->       modifiable! (important!)

        if(l <= lx && rx <= r) // all segments in --> take it
            return segData[ni];

        // intersection --> go deeper
        ll mid = (lx + rx) / 2;

        Node lf = get(l, r, 2*ni + 1, lx, mid);
        Node ri = get(l, r, 2*ni + 2, mid, rx);

        if(r <= mid) // totally in left
            return lf;
        else if(mid <= l) // totally in right
            return ri;
        else // merge
            return merge(lf, ri);
    }
    Node get_range(ll l, ll r) { return get(l, r, 0, 0, leaf_size); }
    Node get_node(ll idx) { return get(idx, idx + 1, 0, 0, leaf_size); }




    // more methods...




};


const ll N = (ll)2e6 + 6, sh = (ll)1e6;

struct _data
{
    ll x, t, y1, y2;
};


void solve()
{

    ll n; cin >> n;
    vector < _data > lines;
    for(ll i = 0; i < n; i++)
    {
        ll x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;
        lines.push_back({x1, 1, y1 + sh, y2 + sh});
        lines.push_back({x2, -1, y1 + sh, y2 + sh});
    }

    sort(all(lines), [&](_data &a, _data &b) -> bool { return a.x < b.x; } );
    // sort(all(lines), [&](_data &a, _data &b) -> bool { return array{a.x, a.t} < array{b.x, b.t}; } );


    ll res = 0;


    segTree st = segTree(N);
    vector < ll > b(N, 0);
    st.init(b);


    ll lastx = -1;

    for(const auto &[x, t, y1, y2] : lines)
    {
        ll smY = N;
        if(!st.get_range(0, N).mn) smY -= st.get_range(0, N).freq;

        res += smY  * (x - lastx);

        st.set_range(y1, y2, t);

        lastx = x;
    }
    cout << res << endl;


    return;
}



//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


