

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// struct to speed-up the unordered data structures like map/set.
struct hash_function // unordered + modified hash >> ordered
{   static uint64_t splitmix64(uint64_t x) {
        x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31); }
    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM); } };


//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// struct to use pairs in unordered data structures like set (good time).
struct Pair_Hash
{
    template < typename T1, typename T2 >
    size_t operator()(const pair < T1, T2 > &p) const
    { return hash<T1>()(p.first) ^ (hash<T2>()(p.second) << 1); }
};


//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// struct to use pairs in unordered data structures like set or HT (good time).
struct Pair_Hash
{
    // Splitmix64 function for better hash distribution
    static uint64_t splitmix64(uint64_t x)
    {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    // Hash function for a pair
    template <typename T1, typename T2>
    size_t operator()(const std::pair<T1, T2>& p) const
    {
        static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();
        size_t hash1 = splitmix64(std::hash<T1>{}(p.first) + FIXED_RANDOM);
        size_t hash2 = splitmix64(std::hash<T2>{}(p.second) + FIXED_RANDOM);
        return hash1 ^ (hash2 << 1); // Combine the two hashes
    }
};


//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// CMP for priority queues of pairs
bool Sort_Second_Ascending(const pair <ll, ll> &a, const pair < ll, ll > &b) { if(a.second == b.second) { return a.first <  b.first; } else { return (a.second < b.second); } }
bool Sort_Second_Descending(const pair <ll, ll> &a, const pair < ll, ll > &b) { if(a.second == b.second) { return a.first >  b.first; } else { return (a.second > b.second); } }
struct Sort_Second_Ascending_priority_queue { constexpr bool operator()( pair < ll, ll > const& a, pair < ll, ll > const& b) const noexcept { return a.second > b.second; } };
struct Sort_Second_Descending_priority_queue { constexpr bool operator()( pair< ll, ll > const& a, pair < ll, ll > const& b) const noexcept { return a.second < b.second; } };


//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

struct twoStackQueue {
    stack<pair<ll, ll>> a, b;

    int size() {
        return a.size() + b.size();
    }

    void push(ll val) {
        ll mx = a.empty()? oo : a.top().second;
        a.push({val, max(mx, val)});
    }

    void move() {
        ll mx = oo;
        while(!a.empty()) {
            mx = max(a.top().first, mx);
            b.push({a.top().first, mx});
            a.pop();
        }
    }

    ll getMax() {
        ll mx = oo;

        if(!b.empty())
            mx = max(mx, b.top().second);
        if(!a.empty())
            mx = max(mx, a.top().second);

        return mx;
    }

    void pop() {
        if(b.empty())
            move();
        if(!b.empty())
            b.pop();
    }
};

struct Stack {
    vector<int> st, MAX = { LLONG_MIN };

    void push(int a) {
        st.push_back(a);
        MAX.push_back(max(a, MAX.back()));
    }

    int pop() {
        int ret = st.back();
        st.pop_back();
        MAX.pop_back();
        return ret;
    }

    bool empty() {
        return st.empty();
    }

    int get_max() {
        return MAX.back();
    }
};


struct Queue {
    Stack left, right;

    void push(int x) {
        right.push(x);
    }

    void pop() {
        if (left.empty()) {
            while (not right.empty()) {
                left.push(right.pop());
            }
        }
        left.pop();
    }

    int MAX() {
        return max(left.get_max(), right.get_max());
    }
};



template<class T>
struct Mono_stack {
    stack<pair<T, T>> st;

    void push(const T &val) {
        if (st.empty()) st.emplace(val, val);
        else st.emplace(val, std::max(val, st.top().second));
    }

    void pop() {
        st.pop();
    }

    bool empty() {
        return st.empty();
    }

    int size() {
        return st.size();
    }

    T top() {
        return st.top().first;
    }

    T max() {
        return st.top().second;
    }
};

template<class T>
struct Mono_queue {
    Mono_stack<T> pop_st, push_st;

    void push(const T &val) {
        push_st.push(val);
    }

    void move() {
        if (pop_st.size()) return;
        while (!push_st.empty())
            pop_st.push(push_st.top()),push_st.pop();
    }

    void pop() {
        move();
        pop_st.pop();
    }

    bool empty() {
        return pop_st.empty()&&push_st.empty();
    }

    int size() {
        return pop_st.size()+push_st.size();
    }

    T top() {
        move();
        return pop_st.top();
    }

    T max() {
        if (pop_st.empty())
            return push_st.max();
        if (push_st.empty())
            return pop_st.max();
        return std::max(push_st.max(),pop_st.max());
    }

};








/**
* Monotonic queue to keep track of the minimum and the maximum
* elements so far in the queue in amortized time of O(1).
*/
template<class T>
class monotonic_queue {
	queue<T> qu;
	deque<T> mx, mn;
	public:
	void push(T v) {
		qu.push(v);
		while (mx.size() && mx.back() < v) mx.pop_back();
		mx.push_back(v);
		while (mn.size() && mn.back() > v) mn.pop_back();
		mn.push_back(v);
	}
	void pop() {
		if (mx.front() == qu.front()) mx.pop_front();
		if (mn.front() == qu.front()) mn.pop_front();
		qu.pop();
	}
	T front() const {
		return qu.front();
	}
	T max() const {
		return mx.front();
	}
	T min() const {
		return mn.front();
	}
	size_t size() const {
		return qu.size();
	}
};



