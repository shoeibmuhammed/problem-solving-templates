//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*                         (2) Segment Free with lazy propagation                        */

// update node/range, get node/range in O(logn)  -->  update & get can be two different opertions but u must find a relation between them!
// memory size is O(4n), height of segment tree is (logn)
// every node (i) range is [lx, rx[,  node (i) --> left child node (2*i + 1) with range [lx, (lx + rx)/2[, right child node (2*i + 2) with range [(lx + rx)/2, rx[



struct Node
{

    // get variables

    ll sm;

    ll lazy; // take care of initial value (may be changed to non-zero value!) --> modified in propagation also!
    bool is_lazy;


    Node() // neutral --> used in constructor, init, set, get(can be modified there! --> take care of it!)
    {
        sm = 0;

        lazy = 0;
        is_lazy = 0;
    }

    Node(ll x)
    {
        sm = x;

        lazy = 0;
        is_lazy = 0;
    }


    // set operation (remeber [lx, rx[ !)
    void change(ll x, ll lx, ll rx) // change or modify (sm like lazy!)
    {
        // if i have (r - l) child nodes, and all modified (apply set type operations) by x --> what should be my new value as their parent (get value)?  (segment tree store get!!)

        sm += (x * (rx - lx));
        lazy += x;

        is_lazy = 1;
    }

};


struct segTree
{

    ll leaf_size, tree_size;
    vector < Node > segData;

    segTree(ll n)
    {
        leaf_size = 1;
        while(leaf_size < n) leaf_size *= 2;
        tree_size = 2 * leaf_size;
        segData.resize(tree_size, Node());
    }




    // what we do on each two adjacent nodes to get their parent in O(1) --> modifiable!
    Node merge(Node &lf, Node &ri)
    {
        Node ans = Node();


        // operations to get ans (parent) node
        ans.sm = lf.sm + ri.sm;


        return ans;
    }




    // Propagation in O(1)
    void propagete(ll ni, ll lx, ll rx)
    {
        if(rx - lx == 1 || segData[ni].is_lazy == 0) return;

        ll mid = (lx + rx) / 2;
        segData[2*ni + 1].change(segData[ni].lazy, lx, mid);
        segData[2*ni + 2].change(segData[ni].lazy, mid, rx);

        segData[ni].lazy = 0;  // modifiable!
        segData[ni].is_lazy = 0;
    }




    // initialization with values in O(n)
    void init(vector < ll > &a, ll ni, ll lx, ll rx)
    {
        if(rx - lx == 1)
        {
            if(lx < (ll)a.size())
                segData[ni] = Node(a[lx]);
            else
                segData[ni] = Node();
            return;
        }

        ll mid = (lx + rx) / 2;
        init(a, 2*ni + 1, lx, mid);
        init(a, 2*ni + 2, mid, rx);

        segData[ni] = merge(segData[2*ni + 1], segData[2*ni + 2]);
    }
    void init(vector < ll > &a) { init(a, 0, 0, leaf_size); }




    // set node/range in O(logn)
    void set(ll l, ll r, ll val, ll ni, ll lx, ll rx) // 0-indexed, [lx, rx[
    {
        propagete(ni, lx, rx);

        if(lx >= r || rx <= l) return;  // no intersection --> useless node & it's childs

        if(l <= lx && rx <= r) // all segments in --> take it
        {
            segData[ni].change(val, lx, rx);
            return;
        }

        // intersection --> dive deeper
        ll mid = (lx + rx) / 2;

        set(l, r, val, 2*ni + 1, lx, mid);
        set(l, r, val, 2*ni + 2, mid, rx);

        segData[ni] = merge(segData[2*ni + 1], segData[2*ni + 2]);
    }
    void set_range(ll l, ll r, ll val) { set(l, r, val, 0, 0, leaf_size); }
    void set_node(ll idx, ll val) { set(idx, idx + 1, val, 0, 0, leaf_size); }





    // get node/range in O(2*logn)
    Node get(ll l, ll r, ll ni, ll lx, ll rx) // 0-indexed, [lx, rx[
    {
        propagete(ni, lx, rx);

        if(lx >= r || rx <= l) // no intersection --> useless node & it's childs --> return neutral
            return Node(); // default neutral when getting      -->       modifiable! (important!)

        if(l <= lx && rx <= r) // all segments in --> take it
            return segData[ni];

        // intersection --> go deeper
        ll mid = (lx + rx) / 2;

        Node lf = get(l, r, 2*ni + 1, lx, mid);
        Node ri = get(l, r, 2*ni + 2, mid, rx);

        if(r <= mid) // totally in left
            return lf;
        else if(mid <= l) // totally in right
            return ri;
        else // merge
            return merge(lf, ri);
    }
    Node get_range(ll l, ll r) { return get(l, r, 0, 0, leaf_size); }
    Node get_node(ll idx) { return get(idx, idx + 1, 0, 0, leaf_size); }




    // more methods...




};



void solve()
{


    ll n, q; cin >> n >> q;
    vector < ll > a(n);
    for(ll i = 0; i < n; i++)
        cin >> a[i];


    segTree st = segTree(n); // n nodes [0, n[ --> all nodes initialized with neutral
    st.init(a); // initialization in O(n)


    while(q--)
    {

        ll op; cin >> op;

        if(op == 1)
        {
            // l, r (1-indexed) --> l--, r (not included)  -->  [l, r[
            ll l, r, v; cin >> l >> r >> v;

            st.set_range(l, r, v);
        }
        else
        {
            // l, r (1-indexed) --> l--, r (not included)  -->  [l, r[
            ll l, r; cin >> l >> r;
            l--;

            cout << st.get_range(l, r).sm << endl;
            cout << st.get_node(l).sm << endl;
        }

    }




    return;
}

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
