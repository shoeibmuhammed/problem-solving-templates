//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                         (2) Segment Tree with lazy propagation with Rollbacks                        */
// Time complexity is O(log2(n)) for all operations
// Memory complexity is O(4*n + q*log2(4n))
//



struct Node
{

    ll sm;
    ll lazy;
    bool is_lazy;

    Node()
    {
        sm = 0;
        lazy = 0;
        is_lazy = 0;
    }

    Node(ll x)
    {
        sm = x;
        lazy = 0;
        is_lazy = 0;
    }
    \
    void change(ll x, ll lx, ll rx)  // remeber [lx, rx[
    {
        sm += (x * (rx - lx));
        lazy += x;
        is_lazy = 1;
    }
};


struct PST
{

    ll leaf_size, tree_size;
    vector < Node > segData;
    ll id;
    vector < ll > checkpoints, vis;
    vector < pair < ll, Node > > history;

    PST(ll n)
    {
        leaf_size = 1;
        while(leaf_size < n) leaf_size *= 2;
        tree_size = 2 * leaf_size;

        segData.resize(tree_size, Node());
        id = 0;
        vis.assign(tree_size, 0);
    }

    Node merge(Node &lf, Node &ri)
    {
        Node ans = Node();

        ans.sm = lf.sm + ri.sm;

        return ans;
    }

    void checkpoint()
    {
        id++;
        checkpoints.push_back((ll)history.size());
    }

    void undo()
    {
        if(checkpoints.empty()) return;

        ll sz = checkpoints.back();
        checkpoints.pop_back();
        while((ll)history.size() > sz)
        {
            auto [ni, v] = history.back();
            history.pop_back();
            segData[ni] = v;
        }
    }

    void propagate(ll ni, ll lx, ll rx)
    {
        if(vis[ni] != id)
        {
            history.push_back({ni, segData[ni]});
            vis[ni] = id;
        }
        if(rx - lx == 1 || segData[ni].is_lazy == 0) return;

        if(vis[2*ni + 1] != id)
        {
            history.push_back({2*ni + 1, segData[2*ni + 1]});
            vis[2*ni + 1] = id;
        }
        if(vis[2*ni + 2] != id)
        {
            history.push_back({2*ni + 2, segData[2*ni + 2]});
            vis[2*ni + 2] = id;
        }

        ll mid = (lx + rx) / 2;
        segData[2*ni + 1].change(segData[ni].lazy, lx, mid);
        segData[2*ni + 2].change(segData[ni].lazy, mid, rx);

        segData[ni].lazy = 0;
        segData[ni].is_lazy = 0;
    }

    void init(vector < ll > &a, ll ni, ll lx, ll rx)
    {
        if(rx - lx == 1)
        {
            if(lx < (ll)a.size())
                segData[ni] = Node(a[lx]);
            else
                segData[ni] = Node();
            return;
        }

        ll mid = (lx + rx) / 2;
        init(a, 2*ni + 1, lx, mid);
        init(a, 2*ni + 2, mid, rx);

        segData[ni] = merge(segData[2*ni + 1], segData[2*ni + 2]);
    }
    void init(vector < ll > &a) { init(a, 0, 0, leaf_size); }

    void set(ll l, ll r, ll val, ll ni, ll lx, ll rx) // 0-indexed, [lx, rx[
    {
        propagate(ni, lx, rx);

        if(lx >= r || rx <= l) return;

        if(l <= lx && rx <= r)
        {
            segData[ni].change(val, lx, rx);
            return;
        }

        ll mid = (lx + rx) / 2;

        set(l, r, val, 2*ni + 1, lx, mid);
        set(l, r, val, 2*ni + 2, mid, rx);

        segData[ni] = merge(segData[2*ni + 1], segData[2*ni + 2]);
    }
    void set_range(ll l, ll r, ll val) { set(l, r, val, 0, 0, leaf_size); }
    void set_node(ll idx, ll val) { set(idx, idx + 1, val, 0, 0, leaf_size); }

    Node get(ll l, ll r, ll ni, ll lx, ll rx) // 0-indexed, [lx, rx[
    {
        propagate(ni, lx, rx);

        if(lx >= r || rx <= l)
            return Node();

        if(l <= lx && rx <= r)
            return segData[ni];

        ll mid = (lx + rx) / 2;

        Node lf = get(l, r, 2*ni + 1, lx, mid);
        Node ri = get(l, r, 2*ni + 2, mid, rx);

        if(r <= mid)
            return lf;
        else if(mid <= l)
            return ri;
        else
            return merge(lf, ri);
    }
    Node get_range(ll l, ll r) { return get(l, r, 0, 0, leaf_size); }
    Node get_node(ll idx) { return get(idx, idx + 1, 0, 0, leaf_size); }

    // more methods...

};



//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


