//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                         SQRT Decomposition                      */
// Ideas:
// (1) Divide the array into Blocks
// (2) Case Processing (combining algorithms) (Light & Heavy)
// (3) Batch Processing / SQRT Decomposition on Queries
// (4) Distinct values
// (5) General ideas
// (6)
//
//
// Notes:
// (1) don't create a big vector inside the main, it'll cause RTE, instead use global array.
// (2) if TLE, don't use SQ = sqrtl(N), instead manually choose the best SQ which minimize the max(O(get), O(set)).
// (3) vector may be faster than set.
// (4)
//
//



//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                         (1) Divide the array into Blocks                      */
// Dynamic Online range queries
// get element/range in O(sqrt(n)), update element in O(1) or O(sqrt(n))
// can't update range
// SQ is the size of each block, where number of blocks = n/SQ
//
// Ideas:
// (1) divide the array into sqrt(n) blocks each size is sqrt(n) approximately
//
// (2) divide the grid into blocks: https://codeforces.com/contest/487/problem/D
//
// (3)
//
// Tricks:
// (1) while(l <= r), can cause TLE bcos multiple modulus operations --> use other method, or is_start vector as flag for start indicies.
//
// (2) if each block need sorted elements, u can use vector and when update just swap to the right position.
//
// (3)
//

// SQRT variables
const ll neutral = 0, N = (ll)2e5 + 5; // modifiable!
const ll SQ = (ll)sqrtl(N) + 1ll; // if TLE, try SQ = (ll)sqrtl(N/log(N)) + 1ll --> when use something like binary search or segment tree --> O(sqrt(n * logn))
vector < ll > block_val;
vector < vector < ll > > block;


// problem variables
ll n, q;
vector < ll > a;


// merge two elements
ll merge(ll x, ll y)
{
    return (x + y); // modifiable!
}


// build SQRT Decomposition in O(n)
void build_SQRT()
{

    block_val.assign(SQ, neutral);
    block.assign(SQ, vector < ll > (SQ, neutral));

    for(ll i = 0; i < n; i++)
    {
        ll block_id = (i / SQ), element_id = (i % SQ);

        block[block_id][element_id] = a[i];

        block_val[block_id] = merge(block_val[block_id], a[i]);
    }

}


// get element/range in O(SQ)
ll get_range(ll l, ll r) // 0-indexed [l, r]
{

    ll ret = neutral;
    while(l <= r)
    {
        if((l % SQ == 0) && (l + SQ - 1 <= r))
        {
            ret = merge(ret, block_val[l/SQ]);
            l += SQ;
        }
        else
        {
            ret = merge(ret, a[l]);
            l++;
        }

    }

    return ret;
}
ll get_element(ll idx) { return get_range(idx, idx); }


// update element in O(1) or O(SQ)
void set_element(ll idx, ll val)
{

    ll block_id = (idx / SQ), element_id = (idx % SQ);

    ll old_val = a[idx];

    // change or modify
    a[idx] = val;
    block[block_id][element_id] = val;


    // update the block value in O(1) --> if u can get the new value of the block without brute force on all it's elements! (sm, mul, ...)
    block_val[block_id] -= old_val;
    block_val[block_id] += block[block_id][element_id];


//    // update the block value in O(SQ) --> if u can't get the new value! (mn, mx, gcd, lcm, ...)
//    block_val[block_id] = neutral;
//    for(ll i = 0; i < SQ; i++)
//        block_val[block_id] = merge(block_val[block_id], block[block_id][i]);

}



void solve()
{

    cin >> n >> q;
    a.assign(n, 0);
    for(auto &i : a) cin >> i;


    build_SQRT();


    while(q--)
    {
        ll op; cin >> op;

        if(op == 1)
        {
            ll idx, val; cin >> idx >> val; // 0-indexed
            idx--;

            set_element(idx, val);
        }
        else
        {
            ll l, r; cin >> l >> r; // 0-indexed, [l, r]
            l--; r--;

            cout << get_range(l, r) << endl;
        }
    }




    return;
}



//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                         (2) Case Processing (Light & Heavy)                         */
// Ideas:
// (1) Case processing:
// given n cells (compute min manhattan distance between two similar characters), there are atmost SQ elements that have frequency > SQ,
// if(frequency < SQ) --> brute force --> O(n * SQ) --> sum(f*f) where f < SQ --> f*sum(f) = SQ*n
// else(frequency >= SQ) --> bfs --> O(SQ * n)
// remember to save answer!
//
// (2) Splitting objects into Light and Heavy nodes:
// If u have a graph with n nodes, m edges, then there aren’t many nodes with big degree (heavy nodes),
// There is at most sqrtl(m) heavy nodes!, and their degree at least sqrtl(m).
// update: Light or Heavy node --> update the Heavy nodes ans in O(SQ) (what does the update affect the ans of the SQ heavy nodes!)
// query: Light node --> brute force over neighbors in O(SQ)
//        Heavy node --> already computed in O(1)
//
// (3)
//
//
// Tricks:
// (1)
//


//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                         (3) Batch Processing / SQRT Decomposition on Queries                         */
// Ideas:
// (1) given q queries, divide them to SQ = sqrtl(q) batches, every update push it in a buffer,
// and every query iterate over the buffer in O(SQ),
// and once the buffer size reaches SQ, apply all buffered updates permanently to your main structure, then clear the buffer.
// time complexity is O(n*SQ + SQ*n)
//
// (2) can work on trees/graphs (good idea): https://codeforces.com/gym/100589/problem/A
//
// (3) usefull in range update queries:
//
//
// Tricks:
// (1)
//


void solve()
{


    ll n, q; cin >> n >> q;
    vector < ll > a(n + 1, 0), pre(n + 1, 0);
    for(ll i = 1; i <= n; i++)
    {
        cin >> a[i];
        pre[i] = pre[i - 1] + a[i];
    }


    ll SQ = (ll)sqrtl(q) + 1ll;
    vector < pair < ll, ll > > buffer;
    while(q--)
    {
        ll op; cin >> op;

        if(op == 1)
        {
            ll i, v; cin >> i >> v; // a[i] += v

            // O(1)
            buffer.push_back({i, v});
        }
        else
        {
            ll l, r; cin >> l >> r;

            // O(n * SQ)
            ll res = pre[r] - pre[l - 1];
            for(const auto &[i, v] : buffer) if(l <= i && i <= r) res += v;
            cout << res << endl;
        }

        // O(SQ * n)
        if((ll)buffer.size() == SQ)
        {
            for(const auto &[i, v] : buffer) a[i] += v;
            for(ll i = 1; i <= n; i++) pre[i] = pre[i - 1] + a[i];

            buffer.clear();
        }
    }



    return;
}




//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                         (4) Distinct values                         */
// Ideas:
// (1) If the sum of N values doesn’t exceed S, then there are at most sqrtl(2*S) distinct values!
//
// (2) In string processing, at most sqrtl(2*S) distinct lengths of given strings.
//
// (3) Knapsack trick --> read the book.
//
//
// Tricks:
// (1)
//
//

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


