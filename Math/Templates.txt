//----------------------------------------------------------------------------------------------------------------


/*              Some Math Shit!               */


// Modular(Binary) Exponentiation: Quick calculation of ((x^n) mod m) in O(log(n))
ll mod_exp(ll x, ll n, ll m = mod)
{
    ll res = 1;
    while(n)
    {
        if(n % 2) res = (((res % m) * (x % m)) % m);
        x = (((x % m) * (x % m)) % m);
        n /= 2;
    }
    return res;
}

// Modular Arithmetic operations
ll mod_mul(ull x , ull y, ll m = mod) { return (((x % m) * (y % m)) % m); }
ll mod_inv(ll x, ll m = mod){ return mod_exp(x , m - 2, m); } // Fermatâ€™s little theorem (m is a prime number)
ll mod_div(ll x, ll y, ll m = mod){ return mod_mul(x, mod_inv(y, m), m); }
ll mod_add(ll x, ll y, ll m = mod) { ll z = (x % m) + (y % m); z %= m; return z; }
ll mod_sub(ll x, ll y, ll m = mod) { ll z = (x % m) - (y % m); while(z < 0) z += m; z %= m; return z; }


// mod_add can cause TLE, bcos multiple assignments in the problem code!


//----------------------------------------------------------------------------------------------------------------


/*              Factor Factorization              */
// Generate the Factors of a number in O(sqrt(n))
// take care from the range of the numbers & the mod


vector < ll > factors;
void get_factors(ll n)
{
    factors.clear();

    ll i = 1;
    for( ; i * i < n; i++)
    {
        if(n % i == 0)
        {
            factors.push_back(i);
            factors.push_back(n / i);
        }
    }
    if(i * i == n)
        factors.push_back(i);
    sort(all(factors));
}


//----------------------------------------------------------------------------------------------------------------


/*              Prime Factorization              */
// Generate the Prime Factors of a number in O(sqrt(n))

vector < ll > prime_factors;
void get_prime_factors(ll n)
{
    prime_factors.clear();
    for(ll i = 2; i * i <= n; i++)
    {
        while(n % i == 0)
        {
            prime_factors.push_back(i);
            n /= i;
        }
    }
    if(n != 1) prime_factors.push_back(n);
}


// if used many times, then don't use the function, copy the body!


//----------------------------------------------------------------------------------------------------------------


// check if a number is prime or not in O(sqrt(n))
ll isprime(ll n) { if(n == 0 || n == 1) { return 0; } for(ll i = 2; i * i <= n; i++) { if(n % i == 0) return 0; } return 1; }


//----------------------------------------------------------------------------------------------------------------


/*              Standard Sieve              */
// Generate the prime numbers <= n, smallest prime factor (spf) for each number in O(nlog(log(n))).


vector < ll > primes, is_prime, spf;
void standard_sieve(ll n)
{
     primes.clear();
     is_prime.assign(n + 1, 1);
     spf.assign(n + 1, 0);

     is_prime[0] = 0; is_prime[1] = 0;
     spf[0] = 0; spf[1] = 1;

     for (ll i = 2; i <= n; i++)
     {
         if (is_prime[i])
         {
             primes.push_back(i);
             spf[i] = i;
             for (ll j = i * i; j <= n; j += i)
             {
                 is_prime[j] = 0;
                 spf[j] = i;
             }
         }
     }
}

//----------------------------------------------------------------------------------------------------------------


/*              Linear Sieve              */
// Generate the prime numbers <= n, smallest prime factor (spf) for each number in O(n).

vector < ll > primes, is_prime, spf;
void linear_sieve(ll n)
{
    primes.clear();
    is_prime.assign(n + 1, 1);
    spf.assign(n + 1, 0);

    is_prime[0] = 0; is_prime[1] = 0;
    spf[0] = 0; spf[1] = 1;

    for(ll i = 2; i <= n; i++)
    {
        if(is_prime[i])
        {
            primes.push_back(i);
            spf[i] = i;
        }

        for(auto p : primes)
        {
            if (i * p > n || p > spf[i]) break;
            is_prime[i * p] = 0;
            spf[i * p] = p;
        }
    }
}

//----------------------------------------------------------------------------------------------------------------
// using sieve, instead from manually iterate over each element is much better!
// see the difference in time in the last two submissions --> https://codeforces.com/contest/1775/my

    vector < ll > primes;
    primes.push_back(2);
    vector < ll > vis((ll)1e3 + 1, 0);
    for(ll i = 3; i < (ll)1e3; i += 2)
    {
        if(vis[i]) continue;
        primes.push_back(i);
        for(ll j = i * i; j < (ll)1e3; j += i) vis[j] = 1;
    }
//----------------------------------------------------------------------------------------------------------------


/*              get the positive root of a quadratic equation               */


ld positive_root(ll a, ll b, ll c)
{
    ll d = (b * b) - (4 * a * c);
    if (d < 0) return -1;
    if(d == 0 && b > 0) return -1;
    ld sqrt_val = sqrt(d);
    return (ld)(-b + sqrt_val) / (2 * a);
}

// determine the sign of the value
ll sgn(ld val) { return (val > eps) - (val < -eps); }

ld positive_root(ld a, ld b, ld c)
{
    ld d = (b * b) - (4 * a * c);
    if (sgn(d) < 0) return -1;
    if(sgn(d) == 0 && sgn(b) > 0) return -1;
    ld sqrt_val = sqrt(d);
    return (ld)(-b + sqrt_val) / (2 * a);
}

//----------------------------------------------------------------------------------------------------------------


/*              GCD, LCM              */
// GCD (Greatest common divisor) in O(log(min(a, b)))
// GCD(a, b) = GCD(b, a % b)


ll gcd (ll a, ll b)
{
    while (b) { a %= b; swap(a, b); }
    return a;
}


// LCM (Least Common Multiple) in O(log(min(a, b)))
// a * b = GCD(a, b) * LCM(a, b)


ll lcm (ll a, ll b) { return (a / gcd(a, b)) * b; }


// ........


ll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }

ll lcm(ll a, ll b)
{
    ll g = gcd(a, b);
    if(a / g >= 1e11 / b) return 1e11;
    else return (a * b) / g;
}


//----------------------------------------------------------------------------------------------------------------





