
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                         (1) FWHT                        */
// Fast Walsh Hadamard Transform (XOR convolution) in O(n * log2(n)).



void fhwt(vector < ll > &f, bool inv)
{
    ll n = f.size();

    for(ll len = 2; len <= n; len <<= 1) // len is the length of each polynomial in the curr level (igonre 1), or the number of points in the curr level.
    {
        for(ll i = 0; i < n; i += len) // the i'th polynomial
        {
            for(ll j = 0; j < len/2; j++) // the j'th element in the i'th polynomial
            {
                ll u = f[i + j], v = f[i + j + len/2]; // even, odd
                f[i + j] = u + v;
                f[i + j + len/2] = u - v;
            }
        }
    }

    if(inv) for(auto &i : f) i /= n;
}

vector < ll > mul_poly_fwht(vector < ll > &a, vector < ll > &b, ll limit = oo)
{
    if(a.empty() || b.empty()) return {};

    vector < ll > fa(all(a)), fb(all(b));

    ll n = 1;
    while(n < ((ll)a.size() + (ll)b.size())) n <<= 1ll;
    fa.resize(n); fb.resize(n);

    fhwt(fa, 0); fhwt(fb, 0); // step 1 & 2

    for(ll i = 0; i < n; i++) fa[i] *= fb[i]; // step 3

    fhwt(fa, 1); // step 4

    vector < ll > ans(n);
    for(ll i = 0; i < n; i++) ans[i] = fa[i];

    return ans;
}

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                         (3) Generalized FWHT                        */
// 0:AND, 1:OR, 2:XOR



//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                         (3) Generalized FWHT with mod                        */
// 0:AND, 1:OR, 2:XOR

const ll inv2 = (mod + 1) >> 1;

ll mod_exp(ll x, ll n, ll m = mod)
{
    ll res = 1;
    while(n)
    {
        if(n % 2) res = (((res % m) * (x % m)) % m);
        x = (((x % m) * (x % m)) % m);
        n /= 2;
    }
    return res;
}
ll mod_mul(ll x , ll y, ll m = mod) { return (((x % m) * (y % m)) % m); }
ll mod_inv(ll x, ll m = mod){ return mod_exp(x , m - 2, m); } // Fermatâ€™s little theorem (m is a prime number)
ll mod_div(ll x, ll y, ll m = mod){ return mod_mul(x, mod_inv(y, m), m); }
ll mod_add(ll x, ll y, ll m = mod) { ll z = (x % m) + (y % m); z %= m; return z; }
ll mod_sub(ll x, ll y, ll m = mod) { ll z = (x % m) - (y % m); while(z < 0) z += m; z %= m; return z; }


void fwht(vector < ll > &f, ll inv, ll flag)
{
    ll n = f.size();

    for(ll len = 2; len <= n; len <<= 1) // len is the length of each polynomial in the curr level (igonre 1), or the number of points in the curr level.
    {
        for(ll i = 0; i < n; i += len) // the i'th polynomial
        {
            for(ll j = 0; j < len/2; j++) // the j'th element in the i'th polynomial
            {
                ll u = f[i + j], v = f[i + j + len/2];

                if(flag == 0) // AND
                {
                    if(!inv) f[i + j] = v, f[i + j + len/2] = mod_add(u, v);
                    else f[i + j] = mod_sub(v, u), f[i + j + len/2] = u;
                }
                else if (flag == 1) // OR
                {
                    if(!inv) f[i + j] = mod_add(u, v), f[i + j + len/2] = u;
                    else f[i + j] = v, f[i + j + len/2] = mod_sub(u, v);
                }
                else // XOR
                {
                    f[i + j] = mod_add(u, v);
                    f[i + j + len/2] = mod_sub(u, v);

                    if(inv)
                    {
                        f[i + j] = mod_mul(f[i + j], inv2);
                        f[i + j + len/2] = mod_mul(f[i + j + len/2], inv2);
                    }
                }
            }
        }
    }

    // if(inv && flag == 2) // iverse && XOR
    // {
    //     ll inv = mod_inv(n);
    //     for (ll i = 0; i < n; ++i) a[i] = mod_mul(a[i], inv);
    // }
}

vector < ll > mul_poly_fwht(vector < ll > a, vector < ll > b, ll limit = oo, ll flag = 2)
{
    if(a.empty() || b.empty()) return {};

    vector < ll > fa(all(a)), fb(all(b));

    ll n = 1;
    while(n < ((ll)a.size() + (ll)b.size())) n <<= 1ll;
    fa.resize(n); fb.resize(n);

    fwht(fa, 0, flag); fwht(fb, 0, flag); // step 1 & 2

    for(ll i = 0; i < n; i++) fa[i] = mod_mul(fa[i], fb[i]); // step 3

    fwht(fa, 1, flag); // step 4

    n = min(n, limit + 1);

    vector < ll > ans(n);
    for(ll i = 0; i < n; i++) ans[i] = fa[i];

    return ans;
}

vector < ll > exp_poly_fhwt1(vector < ll > a, ll k, ll limit = (ll)1e6, ll flag = 2)
{
    if(a.empty()) return {};

    vector < ll > ans = {1};
    while(k)
    {
        if(k & 1ll) ans = mul_poly_fwht(ans, a, limit, flag);
        a = mul_poly_fwht(a, a, limit, flag);
        k >>= 1;
    }
    return ans;
}

// works for XOR only (faster)
vector < ll > exp_poly_fhwt2(vector < ll > a, ll k, ll limit = (ll)1e6)
{
    if(a.empty()) return {};

    ll n = 1;
    while(n < (ll)a.size()) n <<= 1;
    a.resize(n);

    fwht(a, 0, 2);
    for(ll i = 0; i < n; i++) a[i] = mod_exp(a[i], k);
    fwht(a, 1, 2);

    n = min(n, limit + 1);
    a.resize(n);


    return a;
}


//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


