//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                         (1) FFT (recursive) - mine                         */
// recursive FFT algorithm for polynomial multiplication using complex numbers in O(n * log2(n)).
// works with complex long double numbers (can have precision errors), and without mods.
// refernce: {a0, a1 * x, ..., an * x^(n)}, where ai <= 1e6, n <= 1e6.
// + Raise a Polynomial to a power of n, with a limit in O(n * log2(n) * log2(n)).


void fft(vector < cld > &f, bool inv)
{
    ll n = (ll)f.size();

    if(n == 1) return;

    vector < cld > fe(n/2), fo(n/2);
    for(ll i = 0; i < n; i += 2) fe[i/2] = f[i], fo[i/2] = f[i + 1];

    fft(fe, inv), fft(fo, inv);

    cld w(1); // w0 = 1
    cld w1(cos(2.0 * pi * 1.0 / n), (inv ? -1 : 1) * sin(2.0 * pi * 1.0 / n)); // angle = (2 * pi * k / n)

    for(ll i = 0; i < n/2; i++)
    {
        cld u = fe[i], v = w * fo[i]; // even, odd

        f[i] = u + v, f[i + n/2] = u - v;

        if(inv) f[i] /= 2.0, f[i + n/2] /= 2.0; // ( / 2.0) is precision better, but more time complexity bcos multiple division operations.

        w *= w1;
    }

}

vector < ll > mul_poly(vector < ll > &a, vector < ll > &b, ll limit = oo)
{
    if(a.empty() || b.empty()) return {};

    // for(auto &i : a) i = !!i;
    // for(auto &i : b) i = !!i;

    vector < cld > fa(all(a)), fb(all(b));

    ll n = 1ll;
    while(n < ((ll)a.size() + (ll)b.size())) n <<= 1ll;
    fa.resize(n); fb.resize(n);

    fft(fa, 0), fft(fb, 0); // step 1 & 2

    for(ll i = 0; i < n; i++) fa[i] *= fb[i]; // step 3

    fft(fa, 1); // step 4

    n = min(n, limit + 1);

    vector < ll > ans(n);
    for(ll i = 0; i < n; i++) ans[i] = (ll)roundl(fa[i].real()); // (ll)(roundl(fa[i].real()) / n) is low precision, but less time complexity.

    return ans;
}

vector < ll > exp_poly(vector < ll > a, ll k, ll limit = (ll)1e6)
{
    if(a.empty()) return {};
    if(k == 0) return {1};
    if(k == 1) return a;
    if(k == 2) return mul_poly(a, a, limit);

    vector < ll > ans = {1};
    while(k)
    {
        if(k & 1ll) ans = mul_poly(ans, a, limit);
        a = mul_poly(a, a, limit);
        k >>= 1;
    }
    return ans;
}



// .....



//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                         (2) FFT (iterative) - mine (faster)                         */
// iterative FFT algorithm for polynomial multiplication using complex numbers in O(n * log2(n)).
// more memory efficient / faster than the FFT (recursive).
// works with complex long double numbers (can have precision errors), and without mod.
// refernce: {a0, a1 * x, ..., an * x^(n)}, where ai <= 1e6, n <= 1e6.
// + Raise a Polynomial to a power of n, with a limit, in O(n * log2(n) * log2(n)).
// if TLE --> use int, limit, double, ...


void fft(vector < cld > &f, bool inv)
{
    ll n = (ll)f.size();

    // Bit-Reversed order
    for(ll i = 1, j = 0; i < n; i++)
    {
        ll bit = (n >> 1ll); // msb value

        // ++j (+1 from msb (left not right))
        for( ; j & bit; bit >>= 1ll) j ^= bit; // (1 --> 0)
        j ^= bit; // (0 --> 1)

        if(i < j) swap(f[i], f[j]);
    }

    for(ll len = 2; len <= n; len <<= 1ll) // len is the length of each polynomial in the curr level (igonre 1), or the number of points in the curr level.
    {
        cld w1(cos(2.0 * pi * 1.0 / len), (inv ? -1 : 1) * sin(2.0 * pi * 1.0 / len)); // angle = (2 * pi * k / n)

        for(ll i = 0; i < n; i += len) // the i'th polynomial
        {
            cld w(1); // w0 = 1

            for(ll j = 0; j < len/2; j++) // the j'th element in the i'th polynomial
            {
                cld u = f[i + j], v = w * f[i + j + len/2]; // even, odd

                f[i + j] = u + v, f[i + j + len/2] = u - v;

                w *= w1;
            }
        }
    }

    if(inv) for(auto &i : f) i /= n;

}

vector < ll > mul_poly(vector < ll > &a, vector < ll > &b, ll limit = oo)
{
    if(a.empty() || b.empty()) return {};

    // for(auto &i : a) i = !!i;
    // for(auto &i : b) i = !!i;

    vector < cld > fa(all(a)), fb(all(b));

    ll n = 1;
    while(n < ((ll)a.size() + (ll)b.size())) n <<= 1ll;
    fa.resize(n); fb.resize(n);

    fft(fa, 0), fft(fb, 0); // step 1 & 2

    for(ll i = 0; i < n; i++) fa[i] *= fb[i]; // step 3

    fft(fa, 1); // step 4

    n = min(n, limit + 1);

    vector < ll > ans(n);
    for(ll i = 0; i < n; i++) ans[i] = (ll)roundl(fa[i].real());

    return ans;
}

vector < ll > exp_poly(vector < ll > a, ll k, ll limit = (ll)1e6)
{
    if(a.empty()) return {};
    if(k == 0) return {1};
    if(k == 1) return a;
    if(k == 2) return mul_poly(a, a, limit);

    vector < ll > ans = {1};
    while(k)
    {
        if(k & 1ll) ans = mul_poly(ans, a, limit);
        a = mul_poly(a, a, limit);
        k >>= 1;
    }
    return ans;
}

// .....



//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*                         (3) FFT (iterative) with mod - not mine                         */
// iterative FFT algorithm with mod for polynomial multiplication using complex numbers in O(n * log2(n)).
// works with complex long double numbers (can have precision errors), and with all mods (not like ntt).
// refernce: {a0, a1 * x, ...}


const ll special_mod = 998244353; // works with any mod, not like ntt.

// .....

void fft(vector < cd > &a)
{
    ll n = (ll)a.size(), L = 31 - __builtin_clz(n);

    static vector < cld > R(2, 1);
    static vector < cd > rt(2, 1);  // (^ 10% faster if double)

    for(static ll k = 2; k < n; k *= 2)
    {
        R.resize(n); rt.resize(n);
        auto x = polar(1.0L, acos(-1.0L) / k);
        for(static ll i = k; i < 2 * k; i++) rt[i] = R[i] = ((i & 1ll) ? x * R[i/2] : R[i/2]);
    }

    vector < ll > rev(n);
    for(ll i = 0; i < n; i++) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;
    for(ll i = 0; i < n; i++) if(i < rev[i]) swap(a[i], a[rev[i]]);

    for (ll k = 1; k < n; k *= 2)
    {
        for (ll i = 0; i < n; i += 2 * k)
        {
            for(ll j = 0; j < k; j++)
            {
                // C z = rt[j+k] * a[i+j+k];  // (25% faster if hand-rolled)   /// include-line
                auto x = (double *)&rt[j+k], y = (double *)&a[i+j+k];          /// exclude-line
                cd z(x[0]*y[0] - x[1]*y[1], x[0]*y[1] + x[1]*y[0]);            /// exclude-line
                a[i + j + k] = a[i + j] - z;
                a[i + j] += z;
            }
        }
    }
}

vector < ll > mul_poly(vector < ll > &a, vector < ll > &b, ll Mi = special_mod)
{
    if(a.empty() || b.empty()) return {};

    vector < ll > res((ll)a.size() + (ll)b.size() - 1);

    ll B = 32 - __builtin_clz((ll)res.size()), n = (1ll << B), cut = (ll)(sqrtl(Mi));

    vector < cd > L(n), R(n), outs(n), outl(n);
    for(ll i = 0; i < (ll)a.size(); i++) L[i] = cd((ll)a[i] / cut, (ll)a[i] % cut);
    for(ll i = 0; i < (ll)b.size(); i++) R[i] = cd((ll)b[i] / cut, (ll)b[i] % cut);

    fft(L), fft(R);

    for(ll i = 0; i < n; i++)
    {
        ll j = -i & (n - 1);
        outl[j] = (L[i] + conj(L[j])) * R[i] / (2.0 * n);
        outs[j] = (L[i] - conj(L[j])) * R[i] / (2.0 * n) / 1i;
    }

    fft(outl), fft(outs);

    for(ll i = 0; i < (ll)res.size(); i++)
    {
        ll av = ll(real(outl[i]) + 0.5), cv = ll(imag(outs[i]) + 0.5);
        ll bv = ll(imag(outl[i]) + 0.5) + ll(real(outs[i]) + 0.5);
        res[i] = ((av % Mi * cut + bv) % Mi * cut + cv) % Mi;
    }

    return res;
}

// .....



//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



// Multiply two big integers in O(n * log2(n)) + Raise a big integer to a power of n in O(n * log2(n) * log2(n)).



string mul_big_int(string &s1, string &s2)
{
    ll n = (ll)s1.size(), m = (ll)s2.size();

    vector < ll > poly1(n), poly2(m);
    for(ll i = 0; i < n; i++) poly1[n - 1 - i] = (ll)(s1[i] - '0');
    for(ll i = 0; i < m; i++) poly2[m - 1 - i] = (ll)(s2[i] - '0');

    vector < ll > ans = mul_poly(poly1, poly2);
    ll k = (ll)ans.size();

    for(ll i = 0; i < k - 1; i++)
    {
        ans[i + 1] += (ans[i] / 10);
        ans[i] = (ans[i] % 10);
    }

    string s = to_string(ans[k - 1]); // no need to expand
    for(ll i = k - 2; i >= 0; i--) s += (char)(ans[i] + '0');

    for(ll i = 0; i < k; i++) if(s[i] != '0') return s.substr(i);

    return "0";
}

string exp_big_int(string s, ll k)
{
    string ans = "1";
    while(k)
    {
        if(k & 1ll) ans = mul_big_int(ans, s);
        s = mul_big_int(s, s);
        k >>= 1;
    }
    return ans;
}

// ....


//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



